From feb826622404551de3947cd0eb60ffb5d66a6c0e Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 24 Apr 2019 20:16:48 -0700
Subject: [PATCH 1/6] build: Add support for iOS host

Fix build errors with clang
Block driver modified to handle iOS
Slirp driver modified to handle iOS
Calls to system() conditioned on not iOS build
Support iOS icache flushing
---
 block.c                   |  2 +-
 block/file-posix.c        | 38 +++++++++++++++++++-----------
 configure                 | 49 ++++++++++++++++++++++++++++++++++++++-
 net/slirp.c               | 16 ++++++-------
 qga/commands-posix.c      |  6 +++++
 target/arm/arm-semi.c     |  2 ++
 target/m68k/m68k-semi.c   |  2 ++
 target/nios2/nios2-semi.c |  2 ++
 tcg/aarch64/tcg-target.h  | 10 ++++++++
 9 files changed, 104 insertions(+), 23 deletions(-)

diff --git a/block.c b/block.c
index 473eb6eeaa..4d10453a1c 100644
--- a/block.c
+++ b/block.c
@@ -52,7 +52,7 @@
 #ifdef CONFIG_BSD
 #include <sys/ioctl.h>
 #include <sys/queue.h>
-#ifndef __DragonFly__
+#if !defined(__DragonFly__) && !defined(CONFIG_IOS)
 #include <sys/disk.h>
 #endif
 #endif
diff --git a/block/file-posix.c b/block/file-posix.c
index 1b805bd938..98e34f12e8 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -40,7 +40,7 @@
 #include "scsi/pr-manager.h"
 #include "scsi/constants.h"
 
-#if defined(__APPLE__) && (__MACH__)
+#if defined(CONFIG_HOST_DEVICE) && defined(__APPLE__) && (__MACH__)
 #include <paths.h>
 #include <sys/param.h>
 #include <IOKit/IOKitLib.h>
@@ -177,7 +177,16 @@ typedef struct BDRVRawReopenState {
     bool check_cache_dropped;
 } BDRVRawReopenState;
 
-static int fd_open(BlockDriverState *bs);
+static int fd_open(BlockDriverState *bs)
+{
+    BDRVRawState *s = bs->opaque;
+
+    /* this is just to ensure s->fd is sane (its called by io ops) */
+    if (s->fd >= 0)
+        return 0;
+    return -EIO;
+}
+
 static int64_t raw_getlength(BlockDriverState *bs);
 
 typedef struct RawPosixAIOData {
@@ -248,6 +257,12 @@ static int raw_normalize_devicepath(const char **filename, Error **errp)
 }
 #endif
 
+#if defined(CONFIG_IOS)
+static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
+{
+    return -ENOTSUP; // not supported on iOS
+}
+#else /* CONFIG_IOS */
 /*
  * Get logical block size via ioctl. On success store it in @sector_size_p.
  */
@@ -280,6 +295,7 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
 
     return success ? 0 : -errno;
 }
+#endif /* !CONFIG_IOS */
 
 /**
  * Get physical block size of @fd.
@@ -2169,7 +2185,7 @@ again:
         }
         if (size == 0)
 #endif
-#if defined(__APPLE__) && defined(__MACH__)
+#if !defined(CONFIG_IOS) && defined(__APPLE__) && defined(__MACH__)
         {
             uint64_t sectors = 0;
             uint32_t sector_size = 0;
@@ -3045,6 +3061,8 @@ BlockDriver bdrv_file = {
 /***********************************************/
 /* host device */
 
+#if defined(CONFIG_HOST_DEVICE)
+
 #if defined(__APPLE__) && defined(__MACH__)
 static kern_return_t GetBSDPath(io_iterator_t mediaIterator, char *bsdPath,
                                 CFIndex maxPathSize, int flags);
@@ -3381,16 +3399,6 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 }
 #endif /* linux */
 
-static int fd_open(BlockDriverState *bs)
-{
-    BDRVRawState *s = bs->opaque;
-
-    /* this is just to ensure s->fd is sane (its called by io ops) */
-    if (s->fd >= 0)
-        return 0;
-    return -EIO;
-}
-
 static coroutine_fn int
 hdev_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -3778,6 +3786,8 @@ static BlockDriver bdrv_host_cdrom = {
 };
 #endif /* __FreeBSD__ */
 
+#endif /* CONFIG_HOST_DEVICE */
+
 static void bdrv_file_init(void)
 {
     /*
@@ -3785,6 +3795,7 @@ static void bdrv_file_init(void)
      * registered last will get probed first.
      */
     bdrv_register(&bdrv_file);
+#if defined(CONFIG_HOST_DEVICE)
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
     bdrv_register(&bdrv_host_cdrom);
@@ -3792,6 +3803,7 @@ static void bdrv_file_init(void)
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
     bdrv_register(&bdrv_host_cdrom);
 #endif
+#endif /* CONFIG_HOST_DEVICE */
 }
 
 block_init(bdrv_file_init);
diff --git a/configure b/configure
index 6099be1d84..2221ba58d2 100755
--- a/configure
+++ b/configure
@@ -504,6 +504,7 @@ debug_mutex="no"
 libpmem=""
 default_devices="yes"
 plugins="no"
+host_device_support="yes"
 
 supported_cpu="no"
 supported_os="no"
@@ -619,6 +620,19 @@ EOF
   compile_object
 }
 
+check_ios() {
+  cat > $TMPC <<EOF
+#ifdef __APPLE__
+#import "TargetConditionals.h" 
+#if !TARGET_OS_IPHONE
+#error TARGET_OS_IPHONE not true
+#endif
+#endif
+int main(void) { return 0; }
+EOF
+  compile_object
+}
+
 check_include() {
 cat > $TMPC <<EOF
 #include <$1>
@@ -652,7 +666,11 @@ elif check_define __DragonFly__ ; then
 elif check_define __NetBSD__; then
   targetos='NetBSD'
 elif check_define __APPLE__; then
-  targetos='Darwin'
+  if check_ios ; then
+    targetos='iOS'
+  else
+    targetos='Darwin'
+  fi
 else
   # This is a fatal error, but don't report it yet, because we
   # might be going to just print the --help text, or it might
@@ -857,6 +875,27 @@ Darwin)
   HOST_VARIANT_DIR="darwin"
   supported_os="yes"
 ;;
+iOS)
+  bsd="yes"
+  darwin="yes"
+  ios="yes"
+  hax="yes"
+  hvf="yes"
+  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  if [ "$cpu" = "x86_64" ] ; then
+    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
+    LDFLAGS="-arch x86_64 $LDFLAGS"
+  fi
+  host_device_support="no"
+  audio_drv_list=""
+  audio_possible_drivers=""
+  LDFLAGS="-framework CoreFoundation $LDFLAGS"
+  # Disable attempts to use ObjectiveC features in os/object.h since they
+  # won't work when we're compiling with gcc as a C compiler.
+  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
+  HOST_VARIANT_DIR="ios"
+  supported_os="yes"
+;;
 SunOS)
   solaris="yes"
   make="${MAKE-gmake}"
@@ -6599,6 +6638,7 @@ echo "libpmem support   $libpmem"
 echo "libudev           $libudev"
 echo "default devices   $default_devices"
 echo "plugin support    $plugins"
+echo "host device support  $host_device_support"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -6675,6 +6715,9 @@ if test "$default_devices" = "yes" ; then
 else
   echo "CONFIG_MINIKCONF_MODE=--allnoconfig" >> $config_host_mak
 fi
+if test "$host_device_support" = "yes" ; then
+  echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
@@ -6724,6 +6767,10 @@ if test "$darwin" = "yes" ; then
   echo "CONFIG_DARWIN=y" >> $config_host_mak
 fi
 
+if test "$ios" = "yes" ; then
+  echo "CONFIG_IOS=y" >> $config_host_mak
+fi
+
 if test "$solaris" = "yes" ; then
   echo "CONFIG_SOLARIS=y" >> $config_host_mak
 fi
diff --git a/net/slirp.c b/net/slirp.c
index c4334ee876..5afb136d16 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -27,7 +27,7 @@
 #include "net/slirp.h"
 
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 #include <pwd.h>
 #include <sys/wait.h>
 #endif
@@ -90,7 +90,7 @@ typedef struct SlirpState {
     Slirp *slirp;
     Notifier poll_notifier;
     Notifier exit_notifier;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     gchar *smb_dir;
 #endif
     GSList *fwd;
@@ -103,7 +103,7 @@ static QTAILQ_HEAD(, SlirpState) slirp_stacks =
 static int slirp_hostfwd(SlirpState *s, const char *redir_str, Error **errp);
 static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp);
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 static int slirp_smb(SlirpState *s, const char *exported_dir,
                      struct in_addr vserver_addr, Error **errp);
 static void slirp_smb_cleanup(SlirpState *s);
@@ -368,7 +368,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     struct in6_addr ip6_prefix;
     struct in6_addr ip6_host;
     struct in6_addr ip6_dns;
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     struct in_addr smbsrv = { .s_addr = 0 };
 #endif
     NetClientState *nc;
@@ -478,7 +478,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
         return -1;
     }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (vsmbserver && !inet_aton(vsmbserver, &smbsrv)) {
         error_setg(errp, "Failed to parse SMB address");
         return -1;
@@ -593,7 +593,7 @@ static int net_slirp_init(NetClientState *peer, const char *model,
             }
         }
     }
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
     if (smb_export) {
         if (slirp_smb(s, smb_export, smbsrv, errp) < 0) {
             goto error;
@@ -805,7 +805,7 @@ void hmp_hostfwd_add(Monitor *mon, const QDict *qdict)
 
 }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(CONFIG_IOS)
 
 /* automatic user mode samba server configuration */
 static void slirp_smb_cleanup(SlirpState *s)
@@ -920,7 +920,7 @@ static int slirp_smb(SlirpState* s, const char *exported_dir,
     return 0;
 }
 
-#endif /* !defined(_WIN32) */
+#endif /* !defined(_WIN32) && !defined(CONFIG_IOS) */
 
 static int guestfwd_can_read(void *opaque)
 {
diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index 1c1a165dae..41e871fa86 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -33,6 +33,12 @@
 
 #ifndef CONFIG_HAS_ENVIRON
 #ifdef __APPLE__
+#include "TargetConditionals.h"
+#if !TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+#define APPLE_USE_CRT_EXTERNS
+#endif
+#endif
+#ifdef APPLE_USE_CRT_EXTERNS
 #include <crt_externs.h>
 #define environ (*_NSGetEnviron())
 #else
diff --git a/target/arm/arm-semi.c b/target/arm/arm-semi.c
index 6f7b6d801b..9e27f9254c 100644
--- a/target/arm/arm-semi.c
+++ b/target/arm/arm-semi.c
@@ -882,6 +882,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
         return clock() / (CLOCKS_PER_SEC / 100);
     case TARGET_SYS_TIME:
         return set_swi_errno(env, time(NULL));
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case TARGET_SYS_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -898,6 +899,7 @@ target_ulong do_arm_semihosting(CPUARMState *env)
             unlock_user(s, arg0, 0);
             return ret;
         }
+#endif /* CONFIG_IOS */
     case TARGET_SYS_ERRNO:
         return get_swi_errno(env);
     case TARGET_SYS_GET_CMDLINE:
diff --git a/target/m68k/m68k-semi.c b/target/m68k/m68k-semi.c
index 8e5fbfc8fa..598a1b78a2 100644
--- a/target/m68k/m68k-semi.c
+++ b/target/m68k/m68k-semi.c
@@ -402,6 +402,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -420,6 +421,7 @@ void do_m68k_semihosting(CPUM68KState *env, int nr)
             }
         }
         break;
+#endif /* CONFIG_IOS */
     case HOSTED_INIT_SIM:
 #if defined(CONFIG_USER_ONLY)
         {
diff --git a/target/nios2/nios2-semi.c b/target/nios2/nios2-semi.c
index d7a80dd303..bfbaa00bb6 100644
--- a/target/nios2/nios2-semi.c
+++ b/target/nios2/nios2-semi.c
@@ -426,6 +426,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             result = isatty(arg0);
         }
         break;
+#if !defined(CONFIG_IOS) // iOS does not have system()
     case HOSTED_SYSTEM:
         GET_ARG(0);
         GET_ARG(1);
@@ -444,6 +445,7 @@ void do_nios2_semihosting(CPUNios2State *env)
             }
         }
         break;
+#endif
     default:
         qemu_log_mask(LOG_GUEST_ERROR, "nios2-semihosting: unsupported "
                       "semihosting syscall %d\n", nr);
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index ca214f6909..80d3b42b19 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -146,9 +146,19 @@ typedef enum {
 #define TCG_TARGET_DEFAULT_MO (0)
 #define TCG_TARGET_HAS_MEMORY_BSWAP     1
 
+#ifdef __APPLE__
+void sys_icache_invalidate(void *start, size_t len);
+#endif
+
 static inline void flush_icache_range(uintptr_t start, uintptr_t stop)
 {
+#if defined(__APPLE__)
+    sys_icache_invalidate((char *)start, stop-start);
+#elif defined(__GNUC__)
     __builtin___clear_cache((char *)start, (char *)stop);
+#else
+#error "Missing builtin to flush instruction cache"
+#endif
 }
 
 void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
-- 
2.21.1 (Apple Git-122.3)

From 1474e37eaeaca216f00f1d3be72718571fc5f777 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Wed, 27 Mar 2019 14:47:00 -0700
Subject: [PATCH 2/6] build: Added support for building QEMU as a shared
 library

---
 Makefile        | 21 +++++++++++++++++++++
 Makefile.target | 24 +++++++++++++++++++++++-
 configure       | 18 +++++++++++++++++-
 qemu-img.c      |  5 +++++
 rules.mak       |  6 ++++++
 vl.c            |  2 +-
 6 files changed, 73 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index b437a346d7..1c19d6b29e 100644
--- a/Makefile
+++ b/Makefile
@@ -558,6 +558,16 @@ Makefile: $(version-obj-y)
 libqemuutil.a: $(util-obj-y) $(trace-obj-y) $(stub-obj-y)
 libvhost-user.a: $(libvhost-user-obj-y) $(util-obj-y) $(stub-obj-y)
 
+ifdef CONFIG_DARWIN
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.dylib
+else
+QEMU_IMG_SHARED_LIBRARY=libqemu-img.so
+endif
+SOBJS=$(QEMU_IMG_SHARED_LIBRARY)
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS)
+endif
+
 ######################################################################
 
 COMMON_LDADDS = libqemuutil.a
@@ -565,6 +575,11 @@ COMMON_LDADDS = libqemuutil.a
 qemu-img.o: qemu-img-cmds.h
 
 qemu-img$(EXESUF): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+
+$(QEMU_IMG_SHARED_LIBRARY): LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_IMG_SHARED_LIBRARY): qemu-img.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 qemu-nbd$(EXESUF): qemu-nbd.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-io$(EXESUF): qemu-io.o $(authz-obj-y) $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 
@@ -712,6 +727,7 @@ clean: recurse-clean
 		-exec rm {} +
 	rm -f $(edk2-decompressed)
 	rm -f $(filter-out %.tlb,$(TOOLS)) $(HELPERS-y) TAGS cscope.* *.pod *~ */*~
+	rm -f $(SOBJS)
 	rm -f fsdev/*.pod scsi/*.pod
 	rm -f qemu-img-cmds.h
 	rm -f ui/shader/*-vert.h ui/shader/*-frag.h
@@ -873,6 +889,11 @@ install: all $(if $(BUILD_DOCS),install-doc) \
 ifneq ($(TOOLS),)
 	$(call install-prog,$(TOOLS),$(DESTDIR)$(bindir))
 endif
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+endif
 ifneq ($(CONFIG_MODULES),)
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_moddir)"
 	for s in $(modules-m:.mo=$(DSOSUF)); do \
diff --git a/Makefile.target b/Makefile.target
index 24d79d26eb..ee0bedb82d 100644
--- a/Makefile.target
+++ b/Makefile.target
@@ -37,6 +37,14 @@ endif
 endif
 
 PROGS=$(QEMU_PROG) $(QEMU_PROGW)
+
+ifdef CONFIG_DARWIN
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).dylib
+else
+QEMU_SHARED_LIBRARY=lib$(QEMU_PROG).so
+endif
+SOBJS=$(QEMU_SHARED_LIBRARY)
+
 STPFILES=
 
 config-target.h: config-target.h-timestamp
@@ -98,7 +106,11 @@ stap:
 endif
 .PHONY: stap
 
+ifdef CONFIG_SHARED_LIB
+all: $(SOBJS) stap
+else
 all: $(PROGS) stap
+endif
 
 # Dummy command so that make thinks it has done something
 	@true
@@ -211,6 +223,10 @@ ifdef CONFIG_DARWIN
 	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
 endif
 
+$(QEMU_SHARED_LIBRARY): LDFLAGS += $(LDFLAGS_SHARED)
+$(QEMU_SHARED_LIBRARY): $(all-obj-y) $(COMMON_LDADDS)
+	$(call LINK, $(filter-out %.mak, $^))
+
 gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
 	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"GEN","$(TARGET_DIR)$@")
 
@@ -221,7 +237,7 @@ hmp-commands-info.h: $(SRC_PATH)/hmp-commands-info.hx $(SRC_PATH)/scripts/hxtool
 	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"GEN","$(TARGET_DIR)$@")
 
 clean: clean-target
-	rm -f *.a *~ $(PROGS)
+	rm -f *.a *~ $(PROGS) $(SOBJS)
 	rm -f $(shell find . -name '*.[od]')
 	rm -f hmp-commands.h gdbstub-xml.c
 	rm -f trace/generated-helpers.c trace/generated-helpers.c-timestamp
@@ -230,9 +246,15 @@ ifdef CONFIG_TRACE_SYSTEMTAP
 endif
 
 install: all
+ifdef CONFIG_SHARED_LIB
+ifneq ($(SOBJS),)
+	$(call install-so,$(SOBJS),$(DESTDIR)$(libdir))
+endif
+else
 ifneq ($(PROGS),)
 	$(call install-prog,$(PROGS),$(DESTDIR)$(bindir))
 endif
+endif
 ifdef CONFIG_TRACE_SYSTEMTAP
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
 	$(INSTALL_DATA) $(QEMU_PROG).stp-installed "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset/$(QEMU_PROG).stp"
diff --git a/configure b/configure
index 2221ba58d2..ae62e4ea61 100755
--- a/configure
+++ b/configure
@@ -505,6 +505,7 @@ libpmem=""
 default_devices="yes"
 plugins="no"
 host_device_support="yes"
+shared_lib="no"
 
 supported_cpu="no"
 supported_os="no"
@@ -859,6 +860,7 @@ Darwin)
   darwin="yes"
   hax="yes"
   hvf="yes"
+  DSOSUF=".dylib"
   LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
@@ -881,7 +883,8 @@ iOS)
   ios="yes"
   hax="yes"
   hvf="yes"
-  LDFLAGS_SHARED="-bundle -undefined dynamic_lookup"
+  DSOSUF=".dylib"
+  LDFLAGS_SHARED="-dynamiclib"
   if [ "$cpu" = "x86_64" ] ; then
     QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
     LDFLAGS="-arch x86_64 $LDFLAGS"
@@ -1578,6 +1581,14 @@ for opt do
   ;;
   --disable-plugins) plugins="no"
   ;;
+  --enable-shared-lib)
+      shared_lib=yes
+      want_tools=no
+      QEMU_CFLAGS="$QEMU_CFLAGS -fPIC"
+      DSOSUF="-module$DSOSUF" # fix for make 2.81 not building target order correctly
+  ;;
+  --disable-shared-lib) shared_lib=no
+  ;;
   *)
       echo "ERROR: unknown option $opt"
       echo "Try '$0 --help' for more information"
@@ -1761,6 +1772,7 @@ Advanced options (experts only):
                            track the maximum stack usage of stacks created by qemu_alloc_stack
   --enable-plugins
                            enable plugins via shared library loading
+  --enable-shared-lib      build QEMU as a shared library instead of an application
 
 Optional features, enabled with --enable-FEATURE and
 disabled with --disable-FEATURE, default is enabled if available:
@@ -6639,6 +6651,7 @@ echo "libudev           $libudev"
 echo "default devices   $default_devices"
 echo "plugin support    $plugins"
 echo "host device support  $host_device_support"
+echo "build shared lib  $shared_lib"
 
 if test "$supported_cpu" = "no"; then
     echo
@@ -6718,6 +6731,9 @@ fi
 if test "$host_device_support" = "yes" ; then
   echo "CONFIG_HOST_DEVICE=y" >> $config_host_mak
 fi
+if test "$shared_lib" = "yes" ; then
+  echo "CONFIG_SHARED_LIB=y" >> $config_host_mak
+fi
 if test "$debug_tcg" = "yes" ; then
   echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
 fi
diff --git a/qemu-img.c b/qemu-img.c
index 95a24b9762..6500d273dd 100644
--- a/qemu-img.c
+++ b/qemu-img.c
@@ -49,6 +49,11 @@
 #include "crypto/init.h"
 #include "trace/control.h"
 
+#if defined(CONFIG_SHARED_LIB)
+#undef main
+#define main qemu_img_main
+#endif
+
 #define QEMU_IMG_VERSION "qemu-img version " QEMU_FULL_VERSION \
                           "\n" QEMU_COPYRIGHT "\n"
 
diff --git a/rules.mak b/rules.mak
index 967295dd2b..9e9672f804 100644
--- a/rules.mak
+++ b/rules.mak
@@ -154,6 +154,12 @@ define install-prog
 	$(if $(STRIP),$(STRIP) $(foreach T,$1,"$2/$(notdir $T)"),)
 endef
 
+# install-so list, dir
+define install-so
+    $(INSTALL_DIR) "$2"
+    $(INSTALL_LIB) $1 "$2"
+endef
+
 # find-in-path
 # Usage: $(call find-in-path, prog)
 # Looks in the PATH if the argument contains no slash, else only considers one
diff --git a/vl.c b/vl.c
index 6a65a64bfd..3e14194825 100644
--- a/vl.c
+++ b/vl.c
@@ -49,7 +49,7 @@ int main(int argc, char **argv)
 #endif
 #endif /* CONFIG_SDL */
 
-#ifdef CONFIG_COCOA
+#if defined(CONFIG_COCOA) || defined(CONFIG_SHARED_LIB)
 #undef main
 #define main qemu_main
 #endif /* CONFIG_COCOA */
-- 
2.21.1 (Apple Git-122.3)

From 4e91fc77d5f7f0dc3a3e0dbaa08018f2a1ce9b2d Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Fri, 29 Mar 2019 15:41:07 -0700
Subject: [PATCH 3/6] coroutine: add libucontext as external library

iOS does not support ucontext natively for aarch64 and the sigaltstack is also unsupported (even worse, it fails silently, see: https://openradar.appspot.com/13002712 )
---
 .gitmodules               |  3 +++
 Makefile                  | 11 +++++++++++
 configure                 | 27 +++++++++++++++++++++++++--
 libucontext               |  1 +
 util/coroutine-ucontext.c |  9 +++++++++
 5 files changed, 49 insertions(+), 2 deletions(-)
 create mode 160000 libucontext

diff --git a/.gitmodules b/.gitmodules
index 19792c9a11..5127b48928 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -61,3 +61,6 @@
 [submodule "roms/qboot"]
 	path = roms/qboot
 	url = https://github.com/bonzini/qboot
+[submodule "libucontext"]
+	path = libucontext
+	url = https://github.com/halts/libucontext.git
diff --git a/Makefile b/Makefile
index 1c19d6b29e..b2554d8847 100644
--- a/Makefile
+++ b/Makefile
@@ -513,6 +513,9 @@ CAP_CFLAGS += -DCAPSTONE_HAS_ARM64
 CAP_CFLAGS += -DCAPSTONE_HAS_POWERPC
 CAP_CFLAGS += -DCAPSTONE_HAS_X86
 
+LIBUCONTEXT_CFLAGS = $(CFLAGS) $(QEMU_CFLAGS)
+LIBUCONTEXT_CFLAGS += -DCUSTOM_IMPL
+
 .PHONY: capstone/all
 capstone/all: .git-submodule-status
 	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/capstone CAPSTONE_SHARED=no BUILDDIR="$(BUILD_DIR)/capstone" CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" CFLAGS="$(CAP_CFLAGS)" $(SUBDIR_MAKEFLAGS) $(BUILD_DIR)/capstone/$(LIBCAPSTONE))
@@ -525,11 +528,19 @@ slirp/all: .git-submodule-status
 		CC="$(CC)" AR="$(AR)" 	LD="$(LD)" RANLIB="$(RANLIB)"	\
 		CFLAGS="$(QEMU_CFLAGS) $(CFLAGS)" LDFLAGS="$(LDFLAGS)")
 
+.PHONY: libucontext/all
+libucontext/all: .git-submodule-status
+	$(call quiet-command,$(MAKE) -C $(SRC_PATH)/libucontext \
+		ARCH="$(ARCH)" BUILD_DIR="$(BUILD_DIR)/libucontext" \
+		CC="$(CC)" AR="$(AR)" LD="$(LD)" RANLIB="$(RANLIB)" \
+		CFLAGS="$(LIBUCONTEXT_CFLAGS)")
+
 # Compatibility gunk to keep make working across the rename of targets
 # for recursion, to be removed some time after 4.1.
 subdir-dtc: dtc/all
 subdir-capstone: capstone/all
 subdir-slirp: slirp/all
+subdir-libucontext: libucontext/all
 
 $(filter %/all, $(TARGET_DIRS_RULES)): libqemuutil.a $(common-obj-y) \
 	$(qom-obj-y) $(crypto-user-obj-$(CONFIG_USER_ONLY))
diff --git a/configure b/configure
index ae62e4ea61..64d85ba851 100755
--- a/configure
+++ b/configure
@@ -1759,7 +1759,7 @@ Advanced options (experts only):
   --oss-lib                path to OSS library
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-gcov            enable test coverage analysis with gcov
   --gcov=GCOV              use specified gcov [$gcov_tool]
   --disable-blobs          disable installing provided firmware blobs
@@ -5341,6 +5341,8 @@ if test "$coroutine" = ""; then
     coroutine=win32
   elif test "$ucontext_works" = "yes"; then
     coroutine=ucontext
+  elif test "$ios" = "yes"; then
+    coroutine=libucontext
   else
     coroutine=sigaltstack
   fi
@@ -5364,12 +5366,29 @@ else
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} libucontext"
+  mkdir -p libucontext
+  QEMU_CFLAGS="$QEMU_CFLAGS -I\$(SRC_PATH)/libucontext/include"
+  LIBS="-L\$(BUILD_DIR)/libucontext -lucontext $LIBS"
+  ;;
+esac
+
+if test "$coroutine" == "libucontext"; then
+  coroutine_impl=ucontext
+else
+  coroutine_impl=$coroutine
+fi
+
 if test "$coroutine_pool" = ""; then
   coroutine_pool=yes
 fi
@@ -7246,7 +7265,7 @@ if test "$rbd" = "yes" ; then
   echo "RBD_LIBS=$rbd_libs" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 if test "$coroutine_pool" = "yes" ; then
   echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
 else
@@ -8040,6 +8059,10 @@ fi
 if [ "$capstone" = "git" -o "$capstone" = "internal" ]; then
   echo "config-host.h: capstone/all" >> $config_host_mak
 fi
+if [ "$coroutine" = "libucontext" ]; then
+  echo "config-host.h: subdir-libucontext" >> $config_host_mak
+  echo "CONFIG_LIBUCONTEXT=y" >> $config_host_mak
+fi
 if test -n "$LIBCAPSTONE"; then
   echo "LIBCAPSTONE=$LIBCAPSTONE" >> $config_host_mak
 fi
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index bd593e61bc..86347ad78f 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 
 #ifdef CONFIG_VALGRIND_H
-- 
2.21.1 (Apple Git-122.3)

From 252beadf133c01d157f750903c3b4f20ab31c085 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Fri, 29 Mar 2019 15:40:52 -0700
Subject: [PATCH 4/6] tcg: support exec memory locking

To support iOS which does not allow allocating RWX pages, we can only mmap
initially as RW and later mprotect it as RX. The full details are
documented in docs/devel/ios.rst

This largely reverts 6e3b2bfd6af488a896f7936e99ef160f8f37e6f2

On iOS, because we must lock/unlock executable memory for writing, it does
not make sense to store the TBs in executable memory. Instead, we will use
the beginning of each tcg region for TBs.

In order to make the most effective use of space, after a TLB flush, we
find the average size of a code block in previous allocations and then set
aside enough space for future allocations.

This is less space efficient than storing the TB before the code block but
can be more space efficient than the static allocations before that
implementation.

With multiple TCG contexts there is an issue of one vCPU executing a TB
generated by another vCPU and therefore the executable page unlocking can
happen during the execution.

For each TB, we keep a pointer to the tcg_ctx.code_locked_top_page and can
check that a given TB is executable if either 1) it was generated in the
same host thread as the tcg_ctx (then we would be running it after locking
the memory) or 2) it is below the water level for locked exec page (for
that TCG context). We will only return an existing TB in a search if it
matches either condition.

We do this to prevent having to (mutex) lock while generating code and
ruin the advantages of having multiple TCG threads. However, there is now
the possibility of two vCPUs generating the same TB and we have to just
deal with that overhead.
---
 accel/tcg/cpu-exec.c      |  30 ++++++++-
 accel/tcg/tcg-runtime.c   |   9 +++
 accel/tcg/translate-all.c |  40 +++++++++++
 configure                 |   1 +
 docs/devel/index.rst      |   1 +
 docs/devel/ios.rst        | 120 +++++++++++++++++++++++++++++++++
 include/exec/exec-all.h   |  12 +++-
 include/exec/tb-lookup.h  |   3 +
 tcg/aarch64/tcg-target.h  |   5 ++
 tcg/i386/tcg-target.h     |   4 ++
 tcg/tcg.c                 | 138 +++++++++++++++++++++++++++++++++++++-
 tcg/tcg.h                 |  25 +++++++
 12 files changed, 385 insertions(+), 3 deletions(-)
 create mode 100644 docs/devel/ios.rst

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index c01f59c743..d1c2b6ea1f 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -169,6 +169,18 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
     }
 #endif /* DEBUG_DISAS */
 
+#if defined(CONFIG_NO_RWX)
+    /* We only have to lock the exec memory if we are trying to exec a 
+     * block in a page that is potentially unlocked. If we are using a 
+     * old block that is under the water mark for unlocked page, then 
+     * it is fine to execute without locking anything. We must make 
+     * sure that any cached jumps do not go into potentially unlocked 
+     * memory here. */
+    if (*itb->p_code_locked_top_page < itb->tc.ptr + itb->tc.size) {
+        tb_exec_memory_lock();
+    }
+#endif
+
     ret = tcg_qemu_tb_exec(env, tb_ptr);
     cpu->can_do_io = 1;
     last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
@@ -297,6 +309,9 @@ static bool tb_lookup_cmp(const void *p, const void *d)
     const struct tb_desc *desc = d;
 
     if (tb->pc == desc->pc &&
+#if defined(CONFIG_NO_RWX)
+        tb_is_exec(tb) &&
+#endif
         tb->page_addr[0] == desc->phys_page1 &&
         tb->cs_base == desc->cs_base &&
         tb->flags == desc->flags &&
@@ -418,8 +433,21 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
     }
 #endif
     /* See if we can patch the calling TB. */
+
     if (last_tb) {
-        tb_add_jump(last_tb, tb_exit, tb);
+#if defined(CONFIG_NO_RWX)
+        /* In case of exec locked/unlocked pages, we don't want to link to a page 
+         * that can potentially be unlocked. Therefore, we delay the jump linking 
+         * until the next time we fetch it and we know the unlocked watermark is 
+         * above the tb OR if it ends in the same page as last_tb. */
+        if (((uintptr_t)(last_tb->tc.ptr + last_tb->tc.size - 1) & qemu_host_page_mask) ==
+            ((uintptr_t)(tb->tc.ptr + tb->tc.size) & qemu_host_page_mask) || 
+            (*tb->p_code_locked_top_page >= tb->tc.ptr + tb->tc.size)) {
+#endif // defined(CONFIG_NO_RWX)
+            tb_add_jump(last_tb, tb_exit, tb);
+#if defined(CONFIG_NO_RWX)
+        }
+#endif // defined(CONFIG_NO_RWX)
     }
     return tb;
 }
diff --git a/accel/tcg/tcg-runtime.c b/accel/tcg/tcg-runtime.c
index 8a1e408e31..adec9c801f 100644
--- a/accel/tcg/tcg-runtime.c
+++ b/accel/tcg/tcg-runtime.c
@@ -155,6 +155,15 @@ void *HELPER(lookup_tb_ptr)(CPUArchState *env)
     if (tb == NULL) {
         return tcg_ctx->code_gen_epilogue;
     }
+#if defined(CONFIG_NO_RWX)
+    /* In the corner case that we're executing WITHOUT locking the exec memory 
+     * because the first TB was below the locked mem water level, then we have 
+     * to lock the mem here. */
+    if (tcg_ctx->code_locked_top_page == *tb->p_code_locked_top_page &&
+        tcg_ctx->code_locked_top_page < tb->tc.ptr + tb->tc.size) {
+        tb_exec_memory_lock();
+    }
+#endif
     qemu_log_mask_and_addr(CPU_LOG_EXEC, pc,
                            "Chain %d: %p ["
                            TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 9f48da9472..4ed9d0abaf 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -1030,7 +1030,11 @@ static inline void *alloc_code_gen_buffer(void)
 #else
 static inline void *alloc_code_gen_buffer(void)
 {
+#if defined(CONFIG_NO_RWX) // iOS requires W^X
+    int prot = PROT_WRITE | PROT_READ;
+#else
     int prot = PROT_WRITE | PROT_READ | PROT_EXEC;
+#endif
     int flags = MAP_PRIVATE | MAP_ANONYMOUS;
     uintptr_t start = 0;
     size_t size = tcg_ctx->code_gen_buffer_size;
@@ -1124,6 +1128,9 @@ static bool tb_cmp(const void *ap, const void *bp)
     const TranslationBlock *b = bp;
 
     return a->pc == b->pc &&
+#if defined(CONFIG_NO_RWX) // check if from different regions
+        a->p_code_locked_top_page == b->p_code_locked_top_page &&
+#endif
         a->cs_base == b->cs_base &&
         a->flags == b->flags &&
         (tb_cflags(a) & CF_HASH_MASK) == (tb_cflags(b) & CF_HASH_MASK) &&
@@ -1754,6 +1761,10 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
     ti = profile_getclock();
 #endif
 
+#if defined(CONFIG_NO_RWX)
+    tcg_exec_memory_unlock(tcg_ctx);
+#endif
+
     gen_code_size = tcg_gen_code(tcg_ctx, tb);
     if (unlikely(gen_code_size < 0)) {
         switch (gen_code_size) {
@@ -1868,9 +1879,19 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
     if (unlikely(existing_tb != tb)) {
         uintptr_t orig_aligned = (uintptr_t)gen_code_buf;
 
+#if defined(CONFIG_NO_RWX)
+        g_assert(tcg_ctx->nb_tbs > 0);
+        atomic_dec(&tcg_ctx->nb_tbs);
+#else // if TB is allocated in the code buffer
         orig_aligned -= ROUND_UP(sizeof(*tb), qemu_icache_linesize);
+#endif
         atomic_set(&tcg_ctx->code_gen_ptr, (void *)orig_aligned);
         return existing_tb;
+    } else {
+#if defined(CONFIG_NO_RWX)
+        /* count total size of code blocks */
+        tcg_ctx->tb_total_sizes += ((uintptr_t)tcg_ctx->code_gen_ptr - (uintptr_t)gen_code_buf);
+#endif
     }
     tcg_tb_insert(tb);
     return tb;
@@ -2674,3 +2695,22 @@ void tcg_flush_softmmu_tlb(CPUState *cs)
     tlb_flush(cs);
 #endif
 }
+
+#if defined(CONFIG_NO_RWX)
+void tb_exec_memory_lock(void)
+{
+    tcg_exec_memory_lock(tcg_ctx);
+}
+
+/* We can execute a TB if it's either 1) running on the same thread 
+ * as the current tcg_ctx or 2) below the exec locked water mark.
+ */
+bool tb_is_exec(const TranslationBlock *tb)
+{
+    const void *code_locked_top_page;
+
+    code_locked_top_page = atomic_read(tb->p_code_locked_top_page);
+    return code_locked_top_page == tcg_ctx->code_locked_top_page || 
+           code_locked_top_page >= tb->tc.ptr + tb->tc.size;
+}
+#endif // defined(CONFIG_NO_RWX)
diff --git a/configure b/configure
index 64d85ba851..22ddc46067 100755
--- a/configure
+++ b/configure
@@ -6804,6 +6804,7 @@ fi
 
 if test "$ios" = "yes" ; then
   echo "CONFIG_IOS=y" >> $config_host_mak
+  echo "CONFIG_NO_RWX=y" >> $config_host_mak
 fi
 
 if test "$solaris" = "yes" ; then
diff --git a/docs/devel/index.rst b/docs/devel/index.rst
index c86a3cdff2..42ef22fd4b 100644
--- a/docs/devel/index.rst
+++ b/docs/devel/index.rst
@@ -23,3 +23,4 @@ Contents:
    secure-coding-practices
    tcg
    tcg-plugins
+   ios
diff --git a/docs/devel/ios.rst b/docs/devel/ios.rst
new file mode 100644
index 0000000000..e415649ce0
--- /dev/null
+++ b/docs/devel/ios.rst
@@ -0,0 +1,120 @@
+===========
+iOS Support
+===========
+
+To run qemu on the iOS platform, some modifications were required. Most of the 
+modifications are conditioned on the ``CONFIG_IOS`` and ``CONFIG_NO_RWX`` 
+configuration variables.
+
+Build support
+-------------
+
+For the code to compile, certain changes in the block driver and the slirp 
+driver had to be made. There is no ``system()`` call, so code requiring it had 
+to be disabled.
+
+``ucontext`` support is broken on iOS. The implementation from ``libucontext`` 
+is used instead.
+
+Because ``fork()`` is not allowed on iOS apps, the option to build qemu and the 
+utilities as shared libraries is added. Note that because qemu does not perform 
+resource cleanup in most cases (open files, allocated memory, etc), it is 
+advisable that the user implements a proxy layer for syscalls so resources can 
+be kept track by the app that uses qemu as a shared library.
+
+Executable memory locking
+-------------------------
+
+The iOS kernel does not permit ``mmap()`` pages with 
+``PROT_READ | PROT_WRITE | PROT_EXEC``. However, it does allow allocating pages 
+with only ``PROT_READ | PROT_WRITE`` and then later calling ``mprotect()`` with 
+``PROT_READ | PROT_EXEC``. A page can never be both writable and executable.
+
+In this document, we will refer to a page that is read-writable as "unlocked" 
+and a page that is read-executable as "locked." Because ``mprotect()`` is an 
+expensive call, we try to defer calling it until we need to and also try to 
+avoid calling it unless it is absolutely needed.
+
+One approach would be to unlock the entire TCG region when a TB translation is 
+being done and then lock the entire region when a TB is about to be executed. 
+This would require thousands of pages to be locked and unlocked all the time. 
+Additionally, it means that different vCPU threads cannot share the same TLB 
+cache.
+
+TB allocation changes
+---------------------
+
+To improve the performance, we first notice that ``tcg_tb_alloc()`` returns a 
+chunk of memory that must be unlocked. A recent change in qemu places the TB 
+structure close to the code buffer in order to improve both cache locality and 
+reduce code size and memory usage. Unfortunately, we have to regress this 
+improvement as any benefit from it is negated with the need to unlock the memory
+whenever we need to mutate the TB structure.
+
+We go back to the old method of statically allocating a large buffer for all 
+TBs in a region. However a few improvements are made. First, we try to respect 
+the locality by making this buffer close to the code. Second, whenever we flush 
+the TB cache, we will use the average size of code blocks to divide up the TCG 
+region into space for TB structures and space for code blocks.
+
+Locked memory water level
+-------------------------
+
+By moving the TB allocation, we made it such that the memory only needs to be 
+unlocked in the context of ``tb_gen_code()``. Because the code buffer pointer 
+only grows downwards (we do not ever "free" code blocks and have holes), we 
+only ever need to unlock at most one page.
+
+We can think of the entire TCG region divided into two sections: the locked 
+section and the unlocked section. At the start, the entire region is unlocked. 
+As more and more code blocks are generated, the allocation pointer moves 
+upwards. We can then lock the memory of any memory below the allocation pointer 
+as the code generated is immutable. Therefore we can keep a second pointer to 
+the highest page boundary the allocation pointer passes and keep all the memory 
+below that pointer (all the way to the start of the region) locked and all the 
+memory above it unlocked. This pointer is our locked water level.
+
+That way, assuming all pages are unlocked at the start, we will progressively 
+lock more pages as more code is generated. The only page we ever need to unlock 
+would be the page pointed to by our locked water level pointer.
+
+In ``tb_gen_code()`` we will call ``mprotect()`` on at most one page in order to
+unlock the top of the water level (if it is currently locked). In 
+``cpu_tb_exec()`` we will call ``mprotect()`` on all pages below the water 
+level that are currently unlocked. This will, in most cases, be one or zero 
+pages with the exception being if multiple pages of code were generated without 
+being executed.
+
+Multiple threads
+----------------
+
+Additional consideration is needed to handle multiple threads. We do not permit 
+one vCPU from executing code on another vCPU if the end of the code is located 
+at it's TCG region's locked water level. The reason is that without having 
+synchronization between threads, we cannot guarantee if the page at the water 
+level is locked or unlocked.
+
+There are multiple places this may happen: when a TB is being looked up in the 
+main loop, when a TB is being looked up as part of ``goto_tb``, and the TB chain 
+caches (where after lookup, we encode a jump so a future call to the first TB 
+will immediately jump into the second TB without lookup).
+
+Since adding synchronization is expensive (holding on thread idle while another 
+one is generating code defeats the purpose of parallel TCG contexts), we 
+implement a lock-less solution. In each TB, we store a pointer to the water 
+level pointer. Whenever a TB is looked up, we check that either 1) the TB 
+belongs to the current thread and therefore we can ensure the memory is locked 
+during execution or 2) the water level of the TCG context that the TB belongs to
+is beyond the end of the TB's code block. This does mean that there might be 
+redundant code generation done by multiple TCG contexts if multiple vCPUs all 
+decide to execute the same block of code at the same time. This should not 
+happen too often.
+
+Similarly, for the TB chain cache, we will only chain a TB if either 1) both 
+TBs' code buffer end pointer resides in the same page and therefore if the 
+memory is locked to execute the first TB, we can jump to the second TB without 
+issue, or 2) the second TB's code block fully resides below the locked water 
+level of its TCG context. This means in some cases (such as two newly minted 
+TBs from two threads happen to be chained), we will not chain the TB when we 
+see it initially but will only chain it after a few subsequent executions and 
+the locked water level has risen.
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index d85e610e85..5ccc948581 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -430,7 +430,11 @@ struct TranslationBlock {
     uintptr_t jmp_list_head;
     uintptr_t jmp_list_next[2];
     uintptr_t jmp_dest[2];
-};
+#if defined(CONFIG_NO_RWX)
+    /* Reference to code_locked_top_page in tcg_ctx */
+    void * const *p_code_locked_top_page;
+#endif
+} __attribute__((aligned(TB_EXIT_MASK+1)));
 
 extern bool parallel_cpus;
 
@@ -579,6 +583,12 @@ void tlb_set_dirty(CPUState *cpu, target_ulong vaddr);
 /* exec.c */
 void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr);
 
+/* translate-all.c */
+#if defined(CONFIG_NO_RWX)
+void tb_exec_memory_lock(void);
+bool tb_is_exec(const TranslationBlock *tb);
+#endif
+
 MemoryRegionSection *
 address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,
                                   hwaddr *xlat, hwaddr *plen,
diff --git a/include/exec/tb-lookup.h b/include/exec/tb-lookup.h
index 26921b6daf..628d605612 100644
--- a/include/exec/tb-lookup.h
+++ b/include/exec/tb-lookup.h
@@ -33,6 +33,9 @@ tb_lookup__cpu_state(CPUState *cpu, target_ulong *pc, target_ulong *cs_base,
     cf_mask |= cpu->cluster_index << CF_CLUSTER_SHIFT;
 
     if (likely(tb &&
+#if defined(CONFIG_NO_RWX)
+               tb_is_exec(tb) &&
+#endif
                tb->pc == *pc &&
                tb->cs_base == *cs_base &&
                tb->flags == *flags &&
diff --git a/tcg/aarch64/tcg-target.h b/tcg/aarch64/tcg-target.h
index 80d3b42b19..51df0c2f63 100644
--- a/tcg/aarch64/tcg-target.h
+++ b/tcg/aarch64/tcg-target.h
@@ -122,7 +122,12 @@ typedef enum {
 #define TCG_TARGET_HAS_muls2_i64        0
 #define TCG_TARGET_HAS_muluh_i64        1
 #define TCG_TARGET_HAS_mulsh_i64        1
+
+#if defined(CONFIG_NO_RWX) // In iOS, we have to unlock exe memory which is very slow
+#define TCG_TARGET_HAS_direct_jump      0
+#else
 #define TCG_TARGET_HAS_direct_jump      1
+#endif
 
 #define TCG_TARGET_HAS_v64              1
 #define TCG_TARGET_HAS_v128             1
diff --git a/tcg/i386/tcg-target.h b/tcg/i386/tcg-target.h
index 928e8b87bb..e78a522251 100644
--- a/tcg/i386/tcg-target.h
+++ b/tcg/i386/tcg-target.h
@@ -133,7 +133,11 @@ extern bool have_avx2;
 #define TCG_TARGET_HAS_muluh_i32        0
 #define TCG_TARGET_HAS_mulsh_i32        0
 #define TCG_TARGET_HAS_goto_ptr         1
+#if defined(CONFIG_NO_RWX) // In iOS, we have to unlock exe memory which is very slow
+#define TCG_TARGET_HAS_direct_jump      0
+#else
 #define TCG_TARGET_HAS_direct_jump      1
+#endif
 
 #if TCG_TARGET_REG_BITS == 64
 /* Keep target addresses zero-extended in a register.  */
diff --git a/tcg/tcg.c b/tcg/tcg.c
index 5475d49ed1..30481f0a00 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -157,6 +157,10 @@ static int tcg_out_ldst_finalize(TCGContext *s);
 
 #define TCG_HIGHWATER 1024
 
+/* For computing the average TB code size, if we seen below this threshold, 
+   then the average is not meaningful and we ignore it. */
+#define TCG_TB_SEEN_THRESHOLD 10
+
 static TCGContext **tcg_ctxs;
 static unsigned int n_tcg_ctxs;
 TCGv_env cpu_env = 0;
@@ -535,6 +539,36 @@ static void tcg_region_bounds(size_t curr_region, void **pstart, void **pend)
     *pend = end;
 }
 
+#if defined(CONFIG_NO_RWX)
+/*
+ * Called before clearing the TBs from last flush.
+ * Uses the average code block size from the last flush
+ * to set aside a chunk of memory for future translations.
+ * `buffer` must be page aligned
+ */
+static void tcg_tbs_alloc(TCGContext *s)
+{
+    size_t average_block_size;
+
+    if (s->nb_tbs < TCG_TB_SEEN_THRESHOLD) {
+        average_block_size = CODE_GEN_AVG_BLOCK_SIZE;
+    } else {
+        average_block_size = s->tb_total_sizes / s->nb_tbs;
+    }
+
+    s->code_gen_max_blocks = s->code_gen_buffer_size / (sizeof(TranslationBlock) + average_block_size);
+    s->tbs = s->code_gen_ptr;
+    /* if buffer is start of region, it should already be aligned */
+    g_assert(((uintptr_t)s->tbs & ~qemu_host_page_mask) == 0);
+    /* Sanity check since we need bottom 2 bits zero. page_mask should cover this. */
+    g_assert(((uintptr_t)s->tbs & TB_EXIT_MASK) == 0);
+    s->code_gen_ptr = (void *)ROUND_UP((uintptr_t)&s->tbs[s->code_gen_max_blocks], qemu_host_page_size);
+    g_assert(s->code_gen_ptr < s->code_gen_highwater);
+    s->nb_tbs = 0;
+    s->tb_total_sizes = 0;
+}
+#endif // defined(CONFIG_NO_RWX)
+
 static void tcg_region_assign(TCGContext *s, size_t curr_region)
 {
     void *start, *end;
@@ -545,6 +579,13 @@ static void tcg_region_assign(TCGContext *s, size_t curr_region)
     s->code_gen_ptr = start;
     s->code_gen_buffer_size = end - start;
     s->code_gen_highwater = end - TCG_HIGHWATER;
+
+#if defined(CONFIG_NO_RWX)
+    tcg_tbs_alloc(s);
+    s->code_locked = 0;
+    g_assert(((uintptr_t)s->code_gen_ptr & ~qemu_host_page_mask) == 0);
+    s->code_locked_top_page = s->code_gen_ptr;
+#endif
 }
 
 static bool tcg_region_alloc__locked(TCGContext *s)
@@ -594,6 +635,10 @@ void tcg_region_reset_all(void)
     qemu_mutex_lock(&region.lock);
     region.current = 0;
     region.agg_size_full = 0;
+#if defined(CONFIG_NO_RWX)
+        /* unlock any locked pages from before */
+        tcg_exec_memory_destroy(region.start, region.end - region.start);
+#endif
 
     for (i = 0; i < n_ctxs; i++) {
         TCGContext *s = atomic_read(&tcg_ctxs[i]);
@@ -688,6 +733,11 @@ void tcg_region_init(void)
 
     n_regions = tcg_n_regions();
 
+#if defined(CONFIG_NO_RWX)
+    /* We shouldn't be translating code yet, so it should not be locked */
+    g_assert(!tcg_init_ctx.code_locked);
+#endif
+
     /* The first region will be 'aligned - buf' bytes larger than the others */
     aligned = QEMU_ALIGN_PTR_UP(buf, page_size);
     g_assert(aligned < tcg_init_ctx.code_gen_buffer + size);
@@ -1018,6 +1068,30 @@ void tcg_context_init(TCGContext *s)
  */
 TranslationBlock *tcg_tb_alloc(TCGContext *s)
 {
+#if defined(CONFIG_NO_RWX)
+    TranslationBlock *tb;
+    int nb_tbs;
+
+retry:
+    /* artifical limit of TBs buffer reached OR we hit highwater mark */
+    nb_tbs = atomic_fetch_inc(&s->nb_tbs);
+    if (unlikely(nb_tbs >= s->code_gen_max_blocks ||
+        s->code_gen_ptr > s->code_gen_highwater)) {
+        // lock this region before moving to the next one
+        tcg_exec_memory_lock(s);
+        if (tcg_region_alloc(s)) {
+            return NULL;
+        }
+        goto retry;
+    }
+    /* we have a tb to work with */
+    tb = &s->tbs[nb_tbs];
+    tb->p_code_locked_top_page = &s->code_locked_top_page;
+    /* bottom two bits used in exit_tb, must be zero */
+    g_assert(((uintptr_t)tb & TB_EXIT_MASK) == 0);
+    s->data_gen_ptr = NULL;
+    return tb;
+#else // !defined(CONFIG_NO_RWX)
     uintptr_t align = qemu_icache_linesize;
     TranslationBlock *tb;
     void *next;
@@ -1035,6 +1109,7 @@ TranslationBlock *tcg_tb_alloc(TCGContext *s)
     atomic_set(&s->code_gen_ptr, next);
     s->data_gen_ptr = NULL;
     return tb;
+#endif // defined(CONFIG_NO_RWX)
 }
 
 void tcg_prologue_init(TCGContext *s)
@@ -1070,17 +1145,34 @@ void tcg_prologue_init(TCGContext *s)
     }
 #endif
 
+#if defined(CONFIG_NO_RWX)
+    /* We need to mark prolog page as W^X, so align to page */
+    s->code_ptr = (void *)ROUND_UP((uintptr_t)s->code_ptr, qemu_host_page_size);
+#endif
+
     buf1 = s->code_ptr;
+    prologue_size = tcg_current_code_size(s);
     flush_icache_range((uintptr_t)buf0, (uintptr_t)buf1);
 
     /* Deduct the prologue from the buffer.  */
-    prologue_size = tcg_current_code_size(s);
     s->code_gen_ptr = buf1;
     s->code_gen_buffer = buf1;
     s->code_buf = buf1;
     total_size -= prologue_size;
     s->code_gen_buffer_size = total_size;
 
+#if defined(CONFIG_NO_RWX)
+    tcg_tbs_alloc(s);
+    /* Mark prologue as executable */
+    if (mprotect(buf0, prologue_size, PROT_READ | PROT_EXEC) < 0) {
+        fprintf(stderr, "Failed to lock exec memory\n");
+        exit(1);
+    }
+    g_assert(((uintptr_t)buf1 & ~qemu_host_page_mask) == 0);
+    s->code_locked = 0;
+    s->code_locked_top_page = buf1;
+#endif
+
     tcg_register_jit(s->code_gen_buffer, total_size);
 
 #ifdef DEBUG_DISAS
@@ -4569,3 +4661,47 @@ void tcg_expand_vec_op(TCGOpcode o, TCGType t, unsigned e, TCGArg a0, ...)
     g_assert_not_reached();
 }
 #endif
+
+#if defined(CONFIG_NO_RWX)
+void tcg_exec_memory_unlock(TCGContext *s)
+{
+    /* We only need to unlock the top page as all the pages above it are 
+       still unlocked */
+    if (s->code_locked)
+    {
+        if (mprotect(s->code_locked_top_page, qemu_host_page_size, PROT_READ | PROT_WRITE) < 0)
+        {
+            fprintf(stderr, "Failed to lock exec memory\n");
+            exit(1);
+        }
+        s->code_locked = 0;
+    }
+}
+
+void tcg_exec_memory_lock(TCGContext *s)
+{
+    if (!s->code_locked)
+    {
+        void *old_top = s->code_locked_top_page;
+        void *new_top = (void *)((uintptr_t)s->code_gen_ptr & qemu_host_page_mask);
+        if (mprotect(old_top, (new_top - old_top) + qemu_host_page_size, PROT_READ | PROT_EXEC) < 0)
+        {
+            fprintf(stderr, "Failed to unlock exec memory\n");
+            exit(1);
+        }
+        s->code_locked_top_page = new_top;
+        s->code_locked = 1;
+    }
+}
+
+void tcg_exec_memory_destroy(void *start, size_t len)
+{
+    g_assert(((uintptr_t)start & ~qemu_host_page_mask) == 0);
+    g_assert((len & ~qemu_host_page_mask) == 0);
+    if (mprotect(start, len, PROT_READ | PROT_WRITE) < 0)
+    {
+        fprintf(stderr, "Failed to unlock exec memory\n");
+        exit(1);
+    }
+}
+#endif // defined(CONFIG_NO_RWX)
diff --git a/tcg/tcg.h b/tcg/tcg.h
index 92ca10dffc..d313687963 100644
--- a/tcg/tcg.h
+++ b/tcg/tcg.h
@@ -625,6 +625,25 @@ struct TCGContext {
     void *code_gen_ptr;
     void *data_gen_ptr;
 
+#if defined(CONFIG_NO_RWX)
+    /* Code memory locking/unlocking. On W^X platforms, we need to keep 
+       track of when a page is RW or RX. We take advantage of the fact 
+       that generated code only grows downwards so at any point in time 
+       we only need to have 1 or 0 page unlocked. */
+    int code_locked;
+    void *code_locked_top_page;
+
+    /* On iOS we cannot store TB before the code buffer because of W^X
+       therefore we need to allocate from some other region of memory. */
+    TranslationBlock *tbs;
+    size_t nb_tbs;
+    size_t code_gen_max_blocks;
+
+    /* We can compute the average size of TB blocks last flush and use 
+       that to compute the number of blocks needed next flush. */
+    uint64_t tb_total_sizes;
+#endif
+
     /* Threshold to flush the translated code buffer.  */
     void *code_gen_highwater;
 
@@ -1216,6 +1235,12 @@ uintptr_t tcg_qemu_tb_exec(CPUArchState *env, uint8_t *tb_ptr);
 
 void tcg_register_jit(void *buf, size_t buf_size);
 
+#if defined(CONFIG_NO_RWX)
+void tcg_exec_memory_unlock(TCGContext *s);
+void tcg_exec_memory_lock(TCGContext *s);
+void tcg_exec_memory_destroy(void *start, size_t len);
+#endif
+
 #if TCG_TARGET_MAYBE_vec
 /* Return zero if the tuple (opc, type, vece) is unsupportable;
    return > 0 if it is directly supportable;
-- 
2.21.1 (Apple Git-122.3)

From cd46296ce807f2b15d006f0ab01794c04c4b564c Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Fri, 5 Apr 2019 14:01:06 -0700
Subject: [PATCH 5/6] tcg (aarch64 target): fix indirect tb jumps

The LDR only works in a +/- 1MiB range. We expand this to a 4GiB range by using ADRP+LDR when needed.
---
 tcg/aarch64/tcg-target.inc.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/tcg/aarch64/tcg-target.inc.c b/tcg/aarch64/tcg-target.inc.c
index 3f921015d3..19a77aae42 100644
--- a/tcg/aarch64/tcg-target.inc.c
+++ b/tcg/aarch64/tcg-target.inc.c
@@ -1898,8 +1898,15 @@ static void tcg_out_op(TCGContext *s, TCGOpcode opc,
         } else {
             /* !TCG_TARGET_HAS_direct_jump */
             tcg_debug_assert(s->tb_jmp_target_addr != NULL);
-            intptr_t offset = tcg_pcrel_diff(s, (s->tb_jmp_target_addr + a0)) >> 2;
-            tcg_out_insn(s, 3305, LDR, offset, TCG_REG_TMP);
+            uintptr_t target_addr = (uintptr_t)(s->tb_jmp_target_addr + a0);
+            ptrdiff_t offset = tcg_pcrel_diff(s, (void *)target_addr);
+            if (offset < 0x100000 && offset > -0x100000) { // check it's in +/- 1MiB range
+                tcg_out_insn(s, 3305, LDR, offset >> 2, TCG_REG_TMP);
+            } else { // TODO: what if +/- 4GiB is not enough?
+                offset = (target_addr >> 12) - ((uintptr_t)s->code_ptr >> 12);
+                tcg_out_insn(s, 3406, ADRP, TCG_REG_TMP, offset);
+                tcg_out_ld(s, TCG_TYPE_PTR, TCG_REG_TMP, TCG_REG_TMP, target_addr & 0xfff);
+            }
         }
         tcg_out_insn(s, 3207, BR, TCG_REG_TMP);
         set_jmp_reset_offset(s, a0);
-- 
2.21.1 (Apple Git-122.3)

From c137085f2495f4be683a158d48c3cee44da3c0b3 Mon Sep 17 00:00:00 2001
From: osy <osy86@users.noreply.github.com>
Date: Sat, 8 Feb 2020 00:26:43 -0800
Subject: [PATCH 6/6] tcg: fix race condition

In cpu_exec_step_atomic(), TB is obtained before entering the critical
section and used after entering it. In that time it is possible for a TLB
flush to happen and invalidate the TB.
---
 accel/tcg/cpu-exec.c      | 8 ++++++++
 accel/tcg/translate-all.c | 5 +++++
 include/exec/exec-all.h   | 1 +
 3 files changed, 14 insertions(+)

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index d1c2b6ea1f..d83b578299 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -250,8 +250,11 @@ void cpu_exec_step_atomic(CPUState *cpu)
     uint32_t flags;
     uint32_t cflags = 1;
     uint32_t cf_mask = cflags & CF_HASH_MASK;
+    unsigned flush_count;
 
     if (sigsetjmp(cpu->jmp_env, 0) == 0) {
+retry:
+        flush_count = tb_flush_count();
         tb = tb_lookup__cpu_state(cpu, &pc, &cs_base, &flags, cf_mask);
         if (tb == NULL) {
             mmap_lock();
@@ -260,6 +263,11 @@ void cpu_exec_step_atomic(CPUState *cpu)
         }
 
         start_exclusive();
+        /* do_tb_flush() might run and make tb invalid */
+        if (flush_count != tb_flush_count()) {
+            end_exclusive();
+            goto retry;
+        }
 
         /* Since we got here, we know that parallel_cpus must be true.  */
         parallel_cpus = false;
diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index 4ed9d0abaf..ecf7d3b53f 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -2696,6 +2696,11 @@ void tcg_flush_softmmu_tlb(CPUState *cs)
 #endif
 }
 
+unsigned tb_flush_count(void)
+{
+    return atomic_read(&tb_ctx.tb_flush_count);
+}
+
 #if defined(CONFIG_NO_RWX)
 void tb_exec_memory_lock(void)
 {
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index 5ccc948581..1bc61fa6d7 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -584,6 +584,7 @@ void tlb_set_dirty(CPUState *cpu, target_ulong vaddr);
 void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr);
 
 /* translate-all.c */
+unsigned tb_flush_count(void);
 #if defined(CONFIG_NO_RWX)
 void tb_exec_memory_lock(void);
 bool tb_is_exec(const TranslationBlock *tb);
-- 
2.21.1 (Apple Git-122.3)

diff -Naur a/libucontext/LICENSE b/libucontext/LICENSE
--- a/libucontext/LICENSE	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/LICENSE	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,9 @@
+Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+
+Permission to use, copy, modify, and/or distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+This software is provided 'as is' and without any warranty, express or
+implied.  In no event shall the authors be liable for any damages arising
+from the use of this software.
diff -Naur a/libucontext/Makefile b/libucontext/Makefile
--- a/libucontext/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/Makefile	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+ARCH := $(shell uname -m)
+
+ROOT_DIR := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+BUILD_DIR ?= .
+
+LIBUCONTEXT = $(BUILD_DIR)/libucontext.a
+
+all: $(LIBUCONTEXT)
+
+CSRCS := $(wildcard arch/${ARCH}/*.c)
+SSRCS := $(wildcard arch/${ARCH}/*.S)
+OBJS := $(CSRCS:%.c=$(BUILD_DIR)/%.o) $(SSRCS:%.S=$(BUILD_DIR)/%.o)
+DEPS := $(OBJS:%.o=%.d)
+
+INC_DIRS := include $(BUILD_DIR)/arch/${ARCH}
+INC_FLAGS := $(addprefix -I,$(INC_DIRS))
+
+override CFLAGS +=					\
+	-DG_LOG_DOMAIN='"ucontext"'			\
+	$(INC_FLAGS)					\
+	-MMD -MP
+
+$(LIBUCONTEXT): $(OBJS)
+
+.PHONY: clean
+
+clean:
+	rm -r $(OBJS) $(DEPS) $(LIBUCONTEXT)
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.c
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+$(BUILD_DIR)/arch/${ARCH}/%.o: $(ROOT_DIR)/arch/${ARCH}/%.S
+	@$(MKDIR_P) $(dir $@)
+	$(call quiet-command,$(CC) $(CFLAGS) -c -o $@ $<,"CC","$@")
+
+%.a:
+	$(call quiet-command,rm -f $@ && $(AR) rcs $@ $^,"AR","$@")
+
+MKDIR_P ?= mkdir -p
+quiet-command-run = $(if $(V),,$(if $2,printf "  %-7s %s\n" $2 $3 && ))$1
+quiet-@ = $(if $(V),,@)
+quiet-command = $(quiet-@)$(call quiet-command-run,$1,$2,$3)
+
+print-%:
+	@echo '$*=$($*)'
+
+.SUFFIXES:
+
+-include $(DEPS)
diff -Naur a/libucontext/README.md b/libucontext/README.md
--- a/libucontext/README.md	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/README.md	2020-01-31 16:28:55.000000000 -0800
@@ -0,0 +1,43 @@
+# `libucontext`
+
+`libucontext` is a library which provides the `ucontext.h` C API.  Unlike other implementations,
+it faithfully follows the kernel process ABI when doing context swaps.
+
+Notably, when combined with `gcompat`, it provides a fully compatible implementation of the ucontext
+functions that are ABI compatible with glibc.
+
+
+## supported architectures
+
+Adding support for new architectures is easy, but you need to know assembly language to do it.
+
+Right now these archs are supported and should work on bare metal:
+
+ * x86
+ * x86_64
+ * armv6+ (`arm`)
+ * aarch64
+ * s390x
+
+These archs require kernel assistance and use a syscall (the only assembly is the trampoline):
+
+ * ppc
+ * ppc64 (ELFv2 ABI spec only, ELFv1 not supported)
+
+
+## building
+
+`libucontext` uses a simple makefile build system.  You should define `ARCH=` at build time, otherwise
+the build system will attempt to guess using `uname -m`.
+
+```
+$ make ARCH=x86_64
+$ make ARCH=x86_64 check
+$ make ARCH=x86_64 DESTDIR=out install
+```
+
+
+## support
+
+`libucontext` is offered as part of the `gcompat` project.  Accordingly, please address all questions
+and bug reports to gcompat@lists.adelielinux.org.
diff -Naur a/libucontext/arch/aarch64/defs.h b/libucontext/arch/aarch64/defs.h
--- a/libucontext/arch/aarch64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+#ifndef __ARCH_AARCH64_DEFS_H
+#define __ARCH_AARCH64_DEFS_H
+
+#define REGSZ   8
+#ifdef CUSTOM_IMPL
+#define R0_OFFSET 56
+#define SP_OFFSET 304
+#define PC_OFFSET 312
+#define PSTATE_OFFSET 320
+#else
+#define R0_OFFSET 184
+#define SP_OFFSET 432
+#define PC_OFFSET 440
+#define PSTATE_OFFSET 448
+#endif
+
+#ifndef FPSIMD_MAGIC
+# define FPSIMD_MAGIC	0x46508001
+#endif
+
+#ifndef ESR_MAGIC
+# define ESR_MAGIC	0x45535201
+#endif
+
+#endif
diff -Naur a/libucontext/arch/aarch64/getcontext.S b/libucontext/arch/aarch64/getcontext.S
--- a/libucontext/arch/aarch64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x0, x1,   [x0, #R0_OFFSET + (0 * REGSZ)]
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* TODO: SIMD / FPRs */
+
+	mov	x0, #0
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/makecontext.c b/libucontext/arch/aarch64/makecontext.c
--- a/libucontext/arch/aarch64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#define UCONTEXT_T libucontext_ucontext_t
+#else
+#define UCONTEXT_T ucontext_t
+#define _GNU_SOURCE
+#include <signal.h>
+#include <string.h>
+#include <stdio.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= argc < 8 ? 0 : argc - 8;
+	sp = (unsigned long *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.sp = (uintptr_t) sp;
+	ucp->uc_mcontext.pc = (uintptr_t) func;
+	ucp->uc_mcontext.regs[19] = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.regs[30] = (uintptr_t) &_start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.regs[0]);
+
+	for (i = 0; (i < argc && i < 8); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/aarch64/setcontext.S b/libucontext/arch/aarch64/setcontext.S
--- a/libucontext/arch/aarch64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* restore GPRs */
+	ldp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	ldp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	ldp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	ldp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	ldp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	ldp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	ldr	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current stack pointer */
+	ldr	x2, [x0, #SP_OFFSET]
+	mov	sp, x2
+
+	/* TODO: SIMD / FPRs */
+
+	/* save current program counter in link register */
+	ldr	x16, [x0, #PC_OFFSET]
+
+	/* restore args */
+	ldp	x2, x3, [x0, #R0_OFFSET + (2 * REGSZ)]
+	ldp	x4, x5, [x0, #R0_OFFSET + (4 * REGSZ)]
+	ldp	x6, x7, [x0, #R0_OFFSET + (6 * REGSZ)]
+	ldp	x0, x1, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* jump to new PC */
+	br	x16
+.align 2
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mov	x0, x19
+	cbnz	x0, _libucontext_setcontext
+
+	/* something went wrong, exit */
+	b	_exit
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/aarch64/swapcontext.S b/libucontext/arch/aarch64/swapcontext.S
--- a/libucontext/arch/aarch64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/aarch64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	str	xzr, [x0, #R0_OFFSET + (0 * REGSZ)]
+
+	/* save GPRs */
+	stp	x2, x3,   [x0, #R0_OFFSET + (2 * REGSZ)]
+	stp	x4, x5,   [x0, #R0_OFFSET + (4 * REGSZ)]
+	stp	x6, x7,   [x0, #R0_OFFSET + (6 * REGSZ)]
+	stp	x8, x9,   [x0, #R0_OFFSET + (8 * REGSZ)]
+	stp	x10, x11, [x0, #R0_OFFSET + (10 * REGSZ)]
+	stp	x12, x13, [x0, #R0_OFFSET + (12 * REGSZ)]
+	stp	x14, x15, [x0, #R0_OFFSET + (14 * REGSZ)]
+	stp	x16, x17, [x0, #R0_OFFSET + (16 * REGSZ)]
+	stp	x18, x19, [x0, #R0_OFFSET + (18 * REGSZ)]
+	stp	x20, x21, [x0, #R0_OFFSET + (20 * REGSZ)]
+	stp	x22, x23, [x0, #R0_OFFSET + (22 * REGSZ)]
+	stp	x24, x25, [x0, #R0_OFFSET + (24 * REGSZ)]
+	stp	x26, x27, [x0, #R0_OFFSET + (26 * REGSZ)]
+	stp	x28, x29, [x0, #R0_OFFSET + (28 * REGSZ)]
+	str	x30,      [x0, #R0_OFFSET + (30 * REGSZ)]
+
+	/* save current program counter in link register */
+	str	x30, [x0, #PC_OFFSET]
+
+	/* save current stack pointer */
+	mov	x2, sp
+	str	x2, [x0, #SP_OFFSET]
+
+	/* save pstate */
+	str	xzr, [x0, #PSTATE_OFFSET]
+
+	/* context to swap to is in x1 so... we move to x0 and call setcontext */
+	/* store our link register in x28 */
+	mov	x28, x30
+
+	/* move x1 to x0 and call setcontext */
+	mov	x0, x1
+	bl	_libucontext_setcontext
+
+	/* hmm, we came back here try to return */
+	mov	x30, x28
+	ret
+.align 2
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/arch/arm/getcontext.S b/libucontext/arch/arm/getcontext.S
--- a/libucontext/arch/arm/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __getcontext;
+__getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r1, r0, #48
+	stmia	r1, {r4-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* return 0 */
+	mov	r0, #0
+	mov	pc, lr
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/arm/makecontext.c b/libucontext/arch/arm/makecontext.c
--- a/libucontext/arch/arm/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdio.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	unsigned long *sp;
+	unsigned long *regp;
+	va_list va;
+	int i;
+
+	sp = (unsigned long *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp = (unsigned long *) (((uintptr_t) sp & -16L) - 8);
+
+	if (argc > 4)
+		sp -= (argc - 4);
+
+	ucp->uc_mcontext.arm_sp = (uintptr_t) sp;
+	ucp->uc_mcontext.arm_pc = (uintptr_t) func;
+	ucp->uc_mcontext.arm_r4 = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.arm_lr = (uintptr_t) &__start_context;
+
+	va_start(va, argc);
+
+	regp = &(ucp->uc_mcontext.arm_r0);
+
+	for (i = 0; (i < argc && i < 4); i++)
+		*regp++ = va_arg (va, unsigned long);
+
+	for (; i < argc; i++)
+		*sp++ = va_arg (va, unsigned long);
+
+	va_end(va);
+
+/*
+	printf("R4 offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_r4));
+	printf("SP offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_sp));
+	printf("LR offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_lr));
+	printf("PC offset = %d\n", offsetof(ucontext_t, uc_mcontext.arm_pc));
+ */
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/arm/setcontext.S b/libucontext/arch/arm/setcontext.S
--- a/libucontext/arch/arm/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __setcontext;
+__setcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r14, r0, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+
+	/* load link register and jump to new context */
+	ldmia	r14, {r14, pc}
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/arm/startcontext.S b/libucontext/arch/arm/startcontext.S
--- a/libucontext/arch/arm/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.fnstart
+.cantunwind
+	nop
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movs	r0, r4
+	bne	__setcontext@plt
+
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	b	exit@plt
diff -Naur a/libucontext/arch/arm/swapcontext.S b/libucontext/arch/arm/swapcontext.S
--- a/libucontext/arch/arm/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/arm/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __swapcontext;
+__swapcontext:
+	/* copy all of the current registers into the ucontext structure */
+	add	r2, r0, #32
+	stmia	r2, {r0-r12}
+	str	r13, [r0,#84]
+	str	r14, [r0,#92]
+
+	/* load new registers from the second ucontext structure */
+	add	r14, r1, #32
+	ldmia	r14, {r0-r12}
+	ldr	r13, [r14, #52]
+	add	r14, r14, #56
+	ldmia	r14, {r14, pc}
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/ppc/defs.h b/libucontext/arch/ppc/defs.h
--- a/libucontext/arch/ppc/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,62 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* lnk register is actually r32 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc/getcontext.c b/libucontext/arch/ppc/getcontext.c
--- a/libucontext/arch/ppc/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc/makecontext.c b/libucontext/arch/ppc/makecontext.c
--- a/libucontext/arch/ppc/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_NIP]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_LNK]  = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gregs[REG_R31]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[REG_SP]   = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gregs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc/setcontext.c b/libucontext/arch/ppc/setcontext.c
--- a/libucontext/arch/ppc/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc/startcontext.S b/libucontext/arch/ppc/startcontext.S
--- a/libucontext/arch/ppc/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	mr.	3,31
+
+	/* if we have no linked context, lets get out of here */
+	beq	no_linked_context
+
+	/* jump to setcontext */
+	bl	__setcontext@local
+
+no_linked_context:
+	b	exit@GOT
diff -Naur a/libucontext/arch/ppc/swapcontext.c b/libucontext/arch/ppc/swapcontext.c
--- a/libucontext/arch/ppc/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/ppc64/defs.h b/libucontext/arch/ppc64/defs.h
--- a/libucontext/arch/ppc64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,65 @@
+#ifndef __ARCH_PPC_DEFS_H
+#define __ARCH_PPC_DEFS_H
+
+#define REG_R0		(0)
+#define REG_R1		(1)
+#define REG_R2		(2)
+#define REG_R3		(3)
+#define REG_R4		(4)
+#define REG_R5		(5)
+#define REG_R6		(6)
+#define REG_R7		(7)
+#define REG_R8		(8)
+#define REG_R9		(9)
+#define REG_R10		(10)
+#define REG_R11		(11)
+#define REG_R12		(12)
+#define REG_R13		(13)
+#define REG_R14		(14)
+#define REG_R15		(15)
+#define REG_R16		(16)
+#define REG_R17		(17)
+#define REG_R18		(18)
+#define REG_R19		(19)
+#define REG_R20		(20)
+#define REG_R21		(21)
+#define REG_R22		(22)
+#define REG_R23		(23)
+#define REG_R24		(24)
+#define REG_R25		(25)
+#define REG_R26		(26)
+#define REG_R27		(27)
+#define REG_R28		(28)
+#define REG_R29		(29)
+#define REG_R30		(30)
+#define REG_R31		(31)
+#define REG_R32		(32)
+#define REG_R33		(33)
+#define REG_R34		(34)
+#define REG_R35		(35)
+#define REG_R36		(36)
+#define REG_R37		(37)
+#define REG_R38		(38)
+#define REG_R39		(39)
+#define REG_R40		(40)
+#define REG_R41		(41)
+#define REG_R42		(42)
+#define REG_R43		(43)
+#define REG_R44		(44)
+#define REG_R45		(45)
+#define REG_R46		(46)
+#define REG_R47		(47)
+
+/* sp register is actually %r1 */
+#define REG_SP		REG_R1
+
+/* nip register is actually %srr0 (r32) */
+#define REG_NIP		REG_R32
+
+/* entry register is actually %r12 */
+#define REG_ENTRY	REG_R12
+
+/* lnk register is actually %r36 */
+#define REG_LNK		REG_R36
+
+#endif
diff -Naur a/libucontext/arch/ppc64/getcontext.c b/libucontext/arch/ppc64/getcontext.c
--- a/libucontext/arch/ppc64/getcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/getcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__getcontext(ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, ucp, NULL, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return 0;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__getcontext) getcontext __attribute__((weak, __alias__("__getcontext")));
diff -Naur a/libucontext/arch/ppc64/makecontext.c b/libucontext/arch/ppc64/makecontext.c
--- a/libucontext/arch/ppc64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link, stack_args;
+
+	stack_args = argc > 8 ? argc - 8 : 0;
+	uc_link = stack_args + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= (uc_link + 1);
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gp_regs[REG_NIP]   = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_LNK]   = (uintptr_t) &__start_context;
+	ucp->uc_mcontext.gp_regs[REG_SP]    = (uintptr_t) sp;
+	ucp->uc_mcontext.gp_regs[REG_ENTRY] = (uintptr_t) func;
+	ucp->uc_mcontext.gp_regs[REG_R31]   = (uintptr_t) ucp->uc_link;
+
+	sp[0] = (uintptr_t) &__start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+	argp = &sp[2];
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+		case 7:
+			ucp->uc_mcontext.gp_regs[i + 3] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/ppc64/setcontext.c b/libucontext/arch/ppc64/setcontext.c
--- a/libucontext/arch/ppc64/setcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/setcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__setcontext(const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, NULL, (void *) ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__setcontext) setcontext __attribute__((weak, __alias__("__setcontext")));
diff -Naur a/libucontext/arch/ppc64/startcontext.S b/libucontext/arch/ppc64/startcontext.S
--- a/libucontext/arch/ppc64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+.hidden __start_context;
+__start_context:
+	cmpdi	31,0			/* test if ucontext link pointer is null */
+	beq	no_linked_context	/* if it is, exit */
+
+	/* now, call SYS_swapcontext */
+	mr      4,31			/* ucp is in r31 */
+	li      3,0			/* don't care about restoring, set oucp to NULL */
+	li      5,1696			/* sizeof(ucontext_t) */
+	li      0,249			/* SYS_swapcontext */
+	sc
+
+	/* we should not wind back up here, if we do, exit with -1 */
+	li	3,-1
+
+no_linked_context:
+	b	exit@GOT
+	nop
diff -Naur a/libucontext/arch/ppc64/swapcontext.c b/libucontext/arch/ppc64/swapcontext.c
--- a/libucontext/arch/ppc64/swapcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/ppc64/swapcontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+
+int
+__swapcontext(ucontext_t *oucp, const ucontext_t *ucp)
+{
+#ifdef SYS_swapcontext
+	int r;
+
+	r = syscall(SYS_swapcontext, oucp, ucp, sizeof(ucontext_t));
+	if (r < 0)
+	{
+		errno = -r;
+		return -1;
+	}
+
+	return r;
+#else
+	errno = ENOSYS;
+	return -1;
+#endif
+}
+
+
+extern __typeof(__swapcontext) swapcontext __attribute__((weak, __alias__("__swapcontext")));
diff -Naur a/libucontext/arch/s390x/defs.h b/libucontext/arch/s390x/defs.h
--- a/libucontext/arch/s390x/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,8 @@
+#ifndef __ARCH_S390X_DEFS_H
+#define __ARCH_S390X_DEFS_H
+
+#define OFFSET_GREGS	(56)
+#define OFFSET_AREGS	(184)
+#define OFFSET_FPREGS	(248)
+
+#endif
diff -Naur a/libucontext/arch/s390x/getcontext.S b/libucontext/arch/s390x/getcontext.S
--- a/libucontext/arch/s390x/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __getcontext;
+__getcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+	la	%r2, 0				/* we will return 0 */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to where we came from */
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/s390x/makecontext.c b/libucontext/arch/s390x/makecontext.c
--- a/libucontext/arch/s390x/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+#include "defs.h"
+
+
+extern void __start_context(void);
+extern int __setcontext(const ucontext_t *ucp);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int stack_args;
+
+	stack_args = argc > 5 ? argc - 5 : 0;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= stack_args;		// maybe +1
+	sp = (greg_t *) (((uintptr_t) sp & -16L));
+
+	ucp->uc_mcontext.gregs[7]  = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[8]  = (uintptr_t) ucp->uc_link;
+	ucp->uc_mcontext.gregs[9]  = (uintptr_t) &__setcontext;
+	ucp->uc_mcontext.gregs[14] = (uintptr_t) &__start_context;
+
+	argp = sp;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+			ucp->uc_mcontext.gregs[i + 2] = va_arg (va, greg_t);
+			break;
+		default:
+			*argp++ = va_arg (va, greg_t);
+			break;
+		}
+
+	va_end(va);
+
+	/* make room for backchain / register save area */
+	sp -= 20;
+	*sp = 0;
+
+	/* set up %r15 as sp */
+	ucp->uc_mcontext.gregs[15] = (uintptr_t) sp;
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/s390x/setcontext.S b/libucontext/arch/s390x/setcontext.S
--- a/libucontext/arch/s390x/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __setcontext;
+__setcontext:
+	lgr	%r1, %r2			/* use %r1 as our working register */
+
+	lam	%a2, %a15, OFFSET_AREGS+8(%r1)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/s390x/startcontext.S b/libucontext/arch/s390x/startcontext.S
--- a/libucontext/arch/s390x/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __start_context;
+__start_context:
+	basr	%r14, %r7			/* run function pointer (%r7) and return here */
+	ltgr	%r8, %r8			/* check to see if uc_link (%r8) is null */
+
+	jz	no_linked_context		/* if we have no linked context, prepare to exit */
+
+	lgr	%r2, %r8			/* copy the uc_link structure address to %r2 */
+	br	%r9				/* call setcontext */
+
+no_linked_context:
+	la	%r2, 0				/* return 0 */
+	brasl	%r14, exit@plt			/* call exit */
+
+	j	.+2				/* crash if exit returns */
diff -Naur a/libucontext/arch/s390x/swapcontext.S b/libucontext/arch/s390x/swapcontext.S
--- a/libucontext/arch/s390x/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/s390x/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+
+.globl __swapcontext;
+__swapcontext:
+	lgr	%r1, %r2			/* use %r1 to save current context to */
+	lgr	%r0, %r3			/* use %r0 for source context */
+
+	stam	%a0, %a15, OFFSET_AREGS(%r1)	/* store access registers */
+	stmg	%r0, %r15, OFFSET_GREGS(%r1)	/* store general-purpose registers */
+
+	lgr	%r2, %r0			/* swap %r0 to %r2 (XXX: figure out why it hates loading from %r0) */
+	lam	%a2, %a15, OFFSET_AREGS+8(%r2)	/* load access registers, but skip %a0 and %a1 which are for TLS */
+	lmg	%r0, %r15, OFFSET_GREGS(%r2)	/* load general-purpose registers */
+
+	br	%r14				/* return to new link register address */
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86/defs.h b/libucontext/arch/x86/defs.h
--- a/libucontext/arch/x86/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/defs.h	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,18 @@
+#ifndef __ARCH_X86_DEFS_H
+#define __ARCH_X86_DEFS_H
+
+#define OFFSET_REG_GS	20
+#define OFFSET_REG_FS	24
+#define OFFSET_REG_ES	28
+#define OFFSET_REG_DS	32
+#define OFFSET_REG_EDI	36
+#define OFFSET_REG_ESI	40
+#define OFFSET_REG_EBP	44
+#define OFFSET_REG_ESP	48
+#define OFFSET_REG_EBX	52
+#define OFFSET_REG_EDX	56
+#define OFFSET_REG_ECX	60
+#define OFFSET_REG_EAX	64
+#define OFFSET_REG_EIP	76
+
+#endif
diff -Naur a/libucontext/arch/x86/getcontext.S b/libucontext/arch/x86/getcontext.S
--- a/libucontext/arch/x86/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __getcontext;
+__getcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+.weak getcontext;
+getcontext = __getcontext;
diff -Naur a/libucontext/arch/x86/makecontext.c b/libucontext/arch/x86/makecontext.c
--- a/libucontext/arch/x86/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/makecontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#define _GNU_SOURCE
+#include <stddef.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+
+
+extern void __start_context(void);
+
+
+void
+__makecontext(ucontext_t *ucp, void (*func)(void), int argc, ...)
+{
+	greg_t *sp, *argp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (greg_t *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_EIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_EBX] = (uintptr_t) argc;
+	ucp->uc_mcontext.gregs[REG_ESP] = (uintptr_t) sp;
+
+	argp = sp;
+	*argp++ = (uintptr_t) &__start_context;
+	*argp++ = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		*argp++ = va_arg (va, greg_t);
+
+	va_end(va);
+}
+
+
+extern __typeof(__makecontext) makecontext __attribute__((weak, __alias__("__makecontext")));
diff -Naur a/libucontext/arch/x86/setcontext.S b/libucontext/arch/x86/setcontext.S
--- a/libucontext/arch/x86/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __setcontext;
+__setcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak setcontext;
+setcontext = __setcontext;
diff -Naur a/libucontext/arch/x86/startcontext.S b/libucontext/arch/x86/startcontext.S
--- a/libucontext/arch/x86/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	leal	(%esp,%ebx,4), %esp
+	cmpl	$0, (%esp)
+
+	/* restore global offset table, exit@plt and __setcontext@plt need this */
+	call	__i686.get_pc_thunk.bx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	__setcontext@plt
+	movl	%eax, (%esp)
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	exit@plt
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
+
+
+__i686.get_pc_thunk.bx:
+	mov	(%esp), %ebx
+	ret
diff -Naur a/libucontext/arch/x86/swapcontext.S b/libucontext/arch/x86/swapcontext.S
--- a/libucontext/arch/x86/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#include "defs.h"
+
+.globl __swapcontext;
+__swapcontext:
+	/* load address of the ucontext structure */
+	movl	4(%esp), %eax
+
+	/* EAX is not a preserved register */
+	movl	$0, OFFSET_REG_EAX(%eax)
+
+	/* copy all of the current registers into the ucontext structure */
+	movl	%ecx, OFFSET_REG_ECX(%eax)
+	movl	%ebx, OFFSET_REG_EBX(%eax)
+	movl	%edx, OFFSET_REG_EDX(%eax)
+	movl	%edi, OFFSET_REG_EDI(%eax)
+	movl	%esi, OFFSET_REG_ESI(%eax)
+	movl	%ebp, OFFSET_REG_EBP(%eax)
+
+	/* the first argument on the stack is the jump target (%eip), so we store it in the EIP
+	   register in the ucontext structure. */
+	movl	(%esp), %ecx
+	movl	%ecx, OFFSET_REG_EIP(%eax)
+
+	/* take the stack pointer address (%esp) offsetting by 4 to skip over the jump target. */
+	leal	4(%esp), %ecx
+	movl	%ecx, OFFSET_REG_ESP(%eax)
+
+	/* finally, save the FS segment register */
+	xorl	%ecx, %ecx
+	movw	%fs, %cx
+	movl	%ecx, OFFSET_REG_FS(%eax)
+
+	/* load address of the ucontext structure */
+	movl	8(%esp), %eax
+
+	/* set up the FS segment register */
+	movl	OFFSET_REG_FS(%eax), %ecx
+	movw	%cx, %fs
+
+	/* fetch the new EIP */
+	movl	OFFSET_REG_EIP(%eax), %ecx
+
+	/* set up the new stack pointer */
+	movl	OFFSET_REG_ESP(%eax), %esp
+
+	/* push the return address onto the stack */
+	pushl	%ecx
+
+	/* set all of the registers */
+	movl	OFFSET_REG_EBX(%eax), %ebx
+	movl	OFFSET_REG_ECX(%eax), %ecx
+	movl	OFFSET_REG_EDX(%eax), %edx
+	movl	OFFSET_REG_EBP(%eax), %ebp
+	movl	OFFSET_REG_EDI(%eax), %edi
+	movl	OFFSET_REG_ESI(%eax), %esi
+	movl	OFFSET_REG_EAX(%eax), %eax
+
+	ret
+
+
+.weak swapcontext;
+swapcontext = __swapcontext;
diff -Naur a/libucontext/arch/x86_64/defs.h b/libucontext/arch/x86_64/defs.h
--- a/libucontext/arch/x86_64/defs.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/defs.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,55 @@
+#ifndef __ARCH_X86_64_DEFS_H
+#define __ARCH_X86_64_DEFS_H
+
+/* Number of each register in the `gregset_t' array.  */
+enum
+{
+  REG_R8 = 0,
+# define REG_R8		REG_R8
+  REG_R9,
+# define REG_R9		REG_R9
+  REG_R10,
+# define REG_R10	REG_R10
+  REG_R11,
+# define REG_R11	REG_R11
+  REG_R12,
+# define REG_R12	REG_R12
+  REG_R13,
+# define REG_R13	REG_R13
+  REG_R14,
+# define REG_R14	REG_R14
+  REG_R15,
+# define REG_R15	REG_R15
+  REG_RDI,
+# define REG_RDI	REG_RDI
+  REG_RSI,
+# define REG_RSI	REG_RSI
+  REG_RBP,
+# define REG_RBP	REG_RBP
+  REG_RBX,
+# define REG_RBX	REG_RBX
+  REG_RDX,
+# define REG_RDX	REG_RDX
+  REG_RAX,
+# define REG_RAX	REG_RAX
+  REG_RCX,
+# define REG_RCX	REG_RCX
+  REG_RSP,
+# define REG_RSP	REG_RSP
+  REG_RIP,
+# define REG_RIP	REG_RIP
+  REG_EFL,
+# define REG_EFL	REG_EFL
+  REG_CSGSFS,		/* Actually short cs, gs, fs, __pad0.  */
+# define REG_CSGSFS	REG_CSGSFS
+  REG_ERR,
+# define REG_ERR	REG_ERR
+  REG_TRAPNO,
+# define REG_TRAPNO	REG_TRAPNO
+  REG_OLDMASK,
+# define REG_OLDMASK	REG_OLDMASK
+  REG_CR2
+# define REG_CR2	REG_CR2
+};
+
+#endif
diff -Naur a/libucontext/arch/x86_64/getcontext.S b/libucontext/arch/x86_64/getcontext.S
--- a/libucontext/arch/x86_64/getcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/getcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_getcontext;
+_libucontext_getcontext:
+	/* copy all of the current registers into the ucontext structure */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak getcontext;
+getcontext = _libucontext_getcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/makecontext.c b/libucontext/arch/x86_64/makecontext.c
--- a/libucontext/arch/x86_64/makecontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/makecontext.c	2020-01-31 20:14:38.000000000 -0800
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <stddef.h>
+#include <stdarg.h>
+#ifdef CUSTOM_IMPL
+#include <libucontext.h>
+#include "defs.h"
+#define UCONTEXT_T libucontext_ucontext_t
+#define GREG_T libucontext_greg_t
+#else
+#define UCONTEXT_T ucontext_t
+#define GREG_T greg_t
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#endif
+#include "defs.h"
+
+
+extern void _start_context(void);
+
+
+void
+libucontext_makecontext(UCONTEXT_T *ucp, void (*func)(void), int argc, ...)
+{
+	GREG_T *sp;
+	va_list va;
+	int i;
+	unsigned int uc_link;
+
+	uc_link = (argc > 6 ? argc - 6 : 0) + 1;
+
+	sp = (GREG_T *) ((uintptr_t) ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size);
+	sp -= uc_link;
+	sp = (GREG_T *) (((uintptr_t) sp & -16L) - 8);
+
+	ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
+	ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[uc_link];
+	ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
+
+	sp[0] = (uintptr_t) &_start_context;
+	sp[uc_link] = (uintptr_t) ucp->uc_link;
+
+	va_start(va, argc);
+
+	for (i = 0; i < argc; i++)
+		switch (i)
+		{
+		case 0:
+			ucp->uc_mcontext.gregs[REG_RDI] = va_arg (va, GREG_T);
+			break;
+		case 1:
+			ucp->uc_mcontext.gregs[REG_RSI] = va_arg (va, GREG_T);
+			break;
+		case 2:
+			ucp->uc_mcontext.gregs[REG_RDX] = va_arg (va, GREG_T);
+			break;
+		case 3:
+			ucp->uc_mcontext.gregs[REG_RCX] = va_arg (va, GREG_T);
+			break;
+		case 4:
+			ucp->uc_mcontext.gregs[REG_R8] = va_arg (va, GREG_T);
+			break;
+		case 5:
+			ucp->uc_mcontext.gregs[REG_R9] = va_arg (va, GREG_T);
+			break;
+		default:
+			sp[i - 5] = va_arg (va, GREG_T);
+			break;
+		}
+
+	va_end(va);
+}
+
+
+#ifndef CUSTOM_IMPL
+extern __typeof(libucontext_makecontext) makecontext __attribute__((weak, __alias__("libucontext_makecontext")));
+#endif
diff -Naur a/libucontext/arch/x86_64/setcontext.S b/libucontext/arch/x86_64/setcontext.S
--- a/libucontext/arch/x86_64/setcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/setcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_setcontext;
+_libucontext_setcontext:
+	/* set all of the registers */
+	movq    40(%rdi), %r8
+	movq    48(%rdi), %r9
+	movq    56(%rdi), %r10
+	movq    64(%rdi), %r11
+	movq    72(%rdi), %r12
+	movq    80(%rdi), %r13
+	movq    88(%rdi), %r14
+	movq    96(%rdi), %r15
+	movq    112(%rdi), %rsi
+	movq    120(%rdi), %rbp
+	movq    128(%rdi), %rbx
+	movq    136(%rdi), %rdx
+	movq    144(%rdi), %rax
+	movq    152(%rdi), %rcx
+	movq    160(%rdi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq   168(%rdi)
+
+	/* finally, set %rdi correctly. */
+	movq    104(%rdi), %rdi
+
+	/* we're all done here, return 0 */
+	xorl    %eax, %eax
+	ret
+
+#ifndef CUSTOM_IMPL
+.weak setcontext;
+setcontext = _libucontext_setcontext;
+#endif
diff -Naur a/libucontext/arch/x86_64/startcontext.S b/libucontext/arch/x86_64/startcontext.S
--- a/libucontext/arch/x86_64/startcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/startcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl __start_context;
+__start_context:
+	/* get the proper context into position and test for NULL */
+	movq	%rbx, %rsp
+	movq	(%rsp), %rdi
+	testq	%rdi, %rdi
+
+	/* if we have no linked context, lets get out of here */
+	je	no_linked_context
+
+	/* call setcontext to switch to the linked context */
+	call	_libucontext_setcontext
+	movq	%rax, %rdi
+
+no_linked_context:
+	/* we are returning into a null context, it seems, so maybe we should exit */
+	call	_exit
+
+	/* something is really hosed, call hlt to force termination */
+	hlt
diff -Naur a/libucontext/arch/x86_64/swapcontext.S b/libucontext/arch/x86_64/swapcontext.S
--- a/libucontext/arch/x86_64/swapcontext.S	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/arch/x86_64/swapcontext.S	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018 William Pitcock <nenolod@dereferenced.org>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * This software is provided 'as is' and without any warranty, express or
+ * implied.  In no event shall the authors be liable for any damages arising
+ * from the use of this software.
+ */
+
+.globl _libucontext_swapcontext;
+_libucontext_swapcontext:
+	/* copy all of the current registers into the ucontext structure pointed by
+	   the first argument */
+	movq	%r8, 40(%rdi)
+	movq	%r9, 48(%rdi)
+	movq	%r10, 56(%rdi)
+	movq	%r11, 64(%rdi)
+	movq	%r12, 72(%rdi)
+	movq	%r13, 80(%rdi)
+	movq	%r14, 88(%rdi)
+	movq	%r15, 96(%rdi)
+	movq	%rdi, 104(%rdi)
+	movq	%rsi, 112(%rdi)
+	movq	%rbp, 120(%rdi)
+	movq	%rbx, 128(%rdi)
+	movq	%rdx, 136(%rdi)
+	movq	$1, 144(%rdi)		/* $1 is %rax */
+	movq	%rcx, 152(%rdi)
+
+	/* the first argument on the stack is the jump target (%rip), so we store it in the RIP
+	   register in the ucontext structure. */
+	movq	(%rsp), %rcx
+	movq	%rcx, 168(%rdi)
+
+	/* finally take the stack pointer address (%rsp) offsetting by 8 to skip over the jump
+	   target. */
+	leaq	8(%rsp), %rcx
+	movq	%rcx, 160(%rdi)
+
+	/* set all of the registers to their new states, stored in the second
+	   ucontext structure */	
+	movq	40(%rsi), %r8
+	movq	48(%rsi), %r9
+	movq	56(%rsi), %r10
+	movq	64(%rsi), %r11
+	movq	72(%rsi), %r12
+	movq	80(%rsi), %r13
+	movq	88(%rsi), %r14
+	movq	96(%rsi), %r15
+	movq	104(%rsi), %rdi
+	movq	120(%rsi), %rbp
+	movq	128(%rsi), %rbx
+	movq	136(%rsi), %rdx
+	movq	144(%rsi), %rax
+	movq	152(%rsi), %rcx
+	movq	160(%rsi), %rsp
+
+	/* set the jump target by pushing it to the stack.
+	   ret will pop the new %rip from the stack, causing us to jump there. */
+	pushq	168(%rsi)
+
+	/* finally, set %rsi correctly since we do not need it anymore. */
+	movq	112(%rsi), %rsi
+
+	/* we're all done here, return 0 */
+	xorl	%eax, %eax
+	ret
+
+
+#ifndef CUSTOM_IMPL
+.weak swapcontext;
+swapcontext = _libucontext_swapcontext;
+#endif
diff -Naur a/libucontext/include/libucontext.h b/libucontext/include/libucontext.h
--- a/libucontext/include/libucontext.h	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/include/libucontext.h	2020-01-31 20:03:51.000000000 -0800
@@ -0,0 +1,126 @@
+#ifndef __LIBUCONTEXT_H
+#define __LIBUCONTEXT_H
+
+#include <stdint.h>
+
+/* Structure describing a signal stack.  */
+typedef struct
+  {
+    void *ss_sp;
+    size_t ss_size;
+    int ss_flags;
+  } libucontext_stack_t;
+
+typedef unsigned long int libucontext_sigset_t;
+
+#if defined(__aarch64__)
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct
+  {
+    unsigned long long int fault_address;
+    unsigned long long int regs[31];
+    unsigned long long int sp;
+    unsigned long long int pc;
+    unsigned long long int pstate;
+    /* This field contains extension records for additional processor
+       state such as the FP/SIMD state.  It has to match the definition
+       of the corresponding field in the sigcontext struct, see the
+       arch/arm64/include/uapi/asm/sigcontext.h linux header for details.  */
+    unsigned char __reserved[4096] __attribute__ ((__aligned__ (16)));
+  } libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_sigset_t uc_sigmask;
+    libucontext_mcontext_t uc_mcontext;
+  } libucontext_ucontext_t;
+#elif defined(__x86_64__)
+/* Type for general register.  */
+typedef long long int libucontext_greg_t;
+
+/* Container for all general registers.  */
+typedef libucontext_greg_t libucontext_gregset_t[23];
+
+struct libucontext_fpxreg
+{
+  unsigned short int significand[4];
+  unsigned short int exponent;
+  unsigned short int __glibc_reserved1[3];
+};
+
+struct libucontext_xmmreg
+{
+  uint32_t  element[4];
+};
+
+struct libucontext_fpstate
+{
+  /* 64-bit FXSAVE format.  */
+  uint16_t    cwd;
+  uint16_t    swd;
+  uint16_t    ftw;
+  uint16_t    fop;
+  uint64_t    rip;
+  uint64_t    rdp;
+  uint32_t    mxcsr;
+  uint32_t    mxcr_mask;
+  struct libucontext_fpxreg _st[8];
+  struct libucontext_xmmreg _xmm[16];
+  uint32_t    __libucontext_reserved1[24];
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct libucontext_fpstate *libucontext_fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct libucontext_mcontext
+  {
+    libucontext_gregset_t gregs;
+    /* Note that fpregs is a pointer.  */
+    libucontext_fpregset_t fpregs;
+    unsigned long long __reserved1 [8];
+} libucontext_mcontext_t;
+
+/* Userlevel context.  */
+typedef struct libucontext_ucontext
+  {
+    unsigned long int uc_flags;
+    struct libucontext_ucontext *uc_link;
+    libucontext_stack_t uc_stack;
+    libucontext_mcontext_t uc_mcontext;
+    libucontext_sigset_t uc_sigmask;
+    struct libucontext_fpstate __fpregs_mem;
+    unsigned long long int __ssp[4];
+  } libucontext_ucontext_t;
+#else
+#error "mcontext not implemented!"
+#endif
+
+/* Get user context and store it in variable pointed to by UCP.  */
+int libucontext_getcontext (libucontext_ucontext_t *__ucp);
+
+/* Set user context from information of variable pointed to by UCP.  */
+int libucontext_setcontext (const libucontext_ucontext_t *__ucp);
+
+/* Save current context in context variable pointed to by OUCP and set
+   context from variable pointed to by UCP.  */
+int libucontext_swapcontext (libucontext_ucontext_t *__restrict __oucp,
+      const libucontext_ucontext_t *__restrict __ucp);
+
+/* Manipulate user context UCP to continue with calling functions FUNC
+   and the ARGC-1 parameters following ARGC when the context is used
+   the next time in `setcontext' or `swapcontext'.
+
+   We cannot say anything about the parameters FUNC takes; `void'
+   is as good as any other choice.  */
+void libucontext_makecontext (libucontext_ucontext_t *__ucp, void (*__func) (void),
+       int __argc, ...);
+
+#endif
diff -Naur a/libucontext/test_libucontext.c b/libucontext/test_libucontext.c
--- a/libucontext/test_libucontext.c	1969-12-31 16:00:00.000000000 -0800
+++ b/libucontext/test_libucontext.c	2020-01-31 20:20:49.000000000 -0800
@@ -0,0 +1,55 @@
+/*
+ * libucontext test program based on POSIX example program.
+ * Public domain.
+ */
+
+#include <stdio.h>
+#include <ucontext.h>
+#include <stdint.h>
+#include <string.h>
+
+
+static ucontext_t ctx[3];
+
+
+static void f1 (void) {
+	printf("start f1\n");
+	swapcontext(&ctx[1], &ctx[2]);
+	printf("finish f1\n");
+}
+
+
+static void f2 (void) {
+	printf("start f2\n");
+	swapcontext(&ctx[2], &ctx[1]);
+	printf("finish f2\n");
+}
+
+
+int main (int argc, const char *argv[]) {
+	char st1[8192];
+	char st2[8192];
+
+
+	/* poison each coroutine's stack memory for debugging purposes */
+	memset(st1, 'A', sizeof st1);
+	memset(st2, 'B', sizeof st2);
+
+
+	getcontext(&ctx[1]);
+	ctx[1].uc_stack.ss_sp = st1;
+	ctx[1].uc_stack.ss_size = sizeof st1;
+	ctx[1].uc_link = &ctx[0];
+	makecontext(&ctx[1], f1, 0);
+
+
+	getcontext(&ctx[2]);
+	ctx[2].uc_stack.ss_sp = st2;
+	ctx[2].uc_stack.ss_size = sizeof st2;
+	ctx[2].uc_link = &ctx[1];
+	makecontext(&ctx[2], f2, 0);
+
+
+	swapcontext(&ctx[0], &ctx[2]);
+	return 0;
+}
